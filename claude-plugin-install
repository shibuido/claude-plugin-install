#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = []
# ///
"""
claude-plugin-install - Install, manage, and remember Claude Code plugins

Workaround for Claude Code bug where plugin installation fails when a plugin
with the same name exists in multiple marketplaces.

Usage:
    ./claude-plugin-install                                         # interactive menu
    ./claude-plugin-install -p plugin@marketplace [options]         # install
    ./claude-plugin-install uninstall plugin@marketplace [options]  # uninstall
    ./claude-plugin-install cache list                              # list remembered plugins
    ./claude-plugin-install log show --last 20                     # show recent invocations

Examples:
    ./claude-plugin-install -p superpowers@superpowers-marketplace
    ./claude-plugin-install -p superpowers@superpowers-marketplace -y  # non-interactive
    ./claude-plugin-install -p superpowers@superpowers-marketplace -n  # dry-run
    ./claude-plugin-install uninstall superpowers@superpowers-marketplace -l -y

Upstream issues:
    https://github.com/anthropics/claude-code/issues/20593
    https://github.com/anthropics/claude-code/issues/14202
"""

import argparse
import json
import os
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Optional


class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    MAGENTA = "\033[95m"
    CYAN = "\033[96m"
    DIM = "\033[2m"


# Module-level verbosity: 0=quiet, 1=info(-v), 2=debug(-vv), 3=trace(-vvv)
VERBOSITY = 0


def color(text: str, c: str) -> str:
    return f"{c}{text}{Colors.RESET}"


def log_info(msg: str) -> None:
    """Shown at -v (VERBOSITY >= 1). Printed to stderr."""
    if VERBOSITY >= 1:
        print(f"{color('INFO:', Colors.BLUE)} {msg}", file=sys.stderr)


def log_debug(msg: str) -> None:
    """Shown at -vv (VERBOSITY >= 2). Printed to stderr."""
    if VERBOSITY >= 2:
        print(f"{color('DEBUG:', Colors.MAGENTA)} {msg}", file=sys.stderr)


def log_trace(msg: str) -> None:
    """Shown at -vvv (VERBOSITY >= 3). Printed to stderr."""
    if VERBOSITY >= 3:
        print(f"{color('TRACE:', Colors.CYAN)} {msg}", file=sys.stderr)


def log_success(msg: str) -> None:
    print(f"{color('[OK]', Colors.GREEN)} {msg}")


def log_warn(msg: str) -> None:
    print(f"{color('WARNING:', Colors.YELLOW)} {msg}", file=sys.stderr)


def log_error(msg: str) -> None:
    print(f"{color('ERROR:', Colors.RED)} {msg}", file=sys.stderr)


def log_step(msg: str) -> None:
    print(f"\n{color('▶', Colors.CYAN)} {color(msg, Colors.BOLD)}")


# === Constants & Paths ===
VERSION = "0.2.0"
LOG_MIN_ENTRIES = 1000
MENU_LIMIT_DEFAULT = 15


def get_cache_dir() -> Path:
    """Get cache directory, respecting XDG_CACHE_HOME."""
    base = Path(os.environ.get("XDG_CACHE_HOME", str(Path.home() / ".cache")))
    return base / "shibuido" / "claude-plugin-install"


def get_cache_paths() -> dict[str, Path]:
    """Get all cache file paths."""
    cache_dir = get_cache_dir()
    return {
        "cache_dir": cache_dir,
        "plugins_cache": cache_dir / "plugins-cache.jsonl",
        "marketplace_cache": cache_dir / "marketplace-cache.jsonl",
        "invocations_log": cache_dir / "invocations.jsonl",
    }


def ensure_cache_dir() -> Path:
    """Create cache directory if it doesn't exist. Returns the path."""
    cache_dir = get_cache_dir()
    cache_dir.mkdir(parents=True, exist_ok=True)
    log_trace(f"Cache directory: {cache_dir}")
    return cache_dir


class CacheManager:
    """Stateless manager for plugins-cache.jsonl and marketplace-cache.jsonl."""

    @staticmethod
    def _read_jsonl(path: Path) -> list[dict]:
        if not path.exists():
            return []
        entries = []
        with open(path) as f:
            for line in f:
                line = line.strip()
                if line:
                    try:
                        entries.append(json.loads(line))
                    except json.JSONDecodeError:
                        log_warn(f"Skipping invalid JSON line in {path}")
        log_trace(f"Read {len(entries)} entries from {path}")
        return entries

    @staticmethod
    def _write_jsonl(path: Path, entries: list[dict]) -> None:
        log_trace(f"Writing {len(entries)} entries to {path}")
        tmp_path = path.with_suffix(".tmp")
        with open(tmp_path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry, separators=(",", ":")) + "\n")
        os.replace(tmp_path, path)
        log_debug(f"Wrote {path}")

    @staticmethod
    def update_plugin(plugin_name: str, marketplace: str, success: bool,
                      description: Optional[str] = None, version: Optional[str] = None) -> None:
        paths = get_cache_paths()
        ensure_cache_dir()
        cache_file = paths["plugins_cache"]
        key = f"{plugin_name}@{marketplace}"
        now = datetime.now().isoformat()
        entries = CacheManager._read_jsonl(cache_file)
        found = False
        for entry in entries:
            if entry.get("key") == key:
                entry["last_used"] = now
                entry["invocation_count"] = entry.get("invocation_count", 0) + 1
                if success:
                    entry["install_count"] = entry.get("install_count", 0) + 1
                    entry["use_count"] = entry.get("use_count", 0) + 1
                if description is not None:
                    entry["description"] = description
                if version is not None:
                    entry["version"] = version
                found = True
                log_debug(f"Updated plugin cache entry: {key}")
                break
        if not found:
            new_entry: dict[str, Any] = {
                "plugin": plugin_name, "marketplace": marketplace, "key": key,
                "first_seen": now, "last_used": now,
                "use_count": 1 if success else 0,
                "install_count": 1 if success else 0,
                "invocation_count": 1,
            }
            if description is not None:
                new_entry["description"] = description
            if version is not None:
                new_entry["version"] = version
            entries.append(new_entry)
            log_debug(f"Added new plugin cache entry: {key}")
        CacheManager._write_jsonl(cache_file, entries)

    @staticmethod
    def update_marketplace(marketplace: str) -> None:
        paths = get_cache_paths()
        ensure_cache_dir()
        cache_file = paths["marketplace_cache"]
        now = datetime.now().isoformat()
        entries = CacheManager._read_jsonl(cache_file)
        found = False
        for entry in entries:
            if entry.get("marketplace") == marketplace:
                entry["last_used"] = now
                found = True
                break
        if not found:
            entries.append({"marketplace": marketplace, "first_seen": now, "last_used": now})
        CacheManager._write_jsonl(cache_file, entries)

    @staticmethod
    def list_plugins() -> list[dict]:
        return CacheManager._read_jsonl(get_cache_paths()["plugins_cache"])

    @staticmethod
    def list_marketplaces() -> list[dict]:
        return CacheManager._read_jsonl(get_cache_paths()["marketplace_cache"])

    @staticmethod
    def remove_plugin(key: str) -> bool:
        paths = get_cache_paths()
        cache_file = paths["plugins_cache"]
        entries = CacheManager._read_jsonl(cache_file)
        before = len(entries)
        entries = [e for e in entries if e.get("key") != key]
        if len(entries) < before:
            CacheManager._write_jsonl(cache_file, entries)
            return True
        return False

    @staticmethod
    def clear() -> None:
        paths = get_cache_paths()
        for key in ("plugins_cache", "marketplace_cache"):
            path = paths[key]
            if path.exists():
                path.unlink()
                log_info(f"Removed {path}")

    @staticmethod
    def read_marketplace_json(marketplace: str) -> Optional[dict]:
        """Read marketplace.json from the local marketplace install directory."""
        known_mp_path = Path.home() / ".claude" / "plugins" / "known_marketplaces.json"
        if not known_mp_path.exists():
            return None
        try:
            with open(known_mp_path) as f:
                known = json.load(f)
        except (json.JSONDecodeError, OSError):
            return None
        mp_info = known.get(marketplace)
        if not mp_info:
            return None
        install_loc = mp_info.get("installLocation")
        if not install_loc:
            return None
        mp_json_path = Path(install_loc) / ".claude-plugin" / "marketplace.json"
        if not mp_json_path.exists():
            log_debug(f"Marketplace JSON not found: {mp_json_path}")
            return None
        try:
            with open(mp_json_path) as f:
                data = json.load(f)
            log_debug(f"Read marketplace JSON: {mp_json_path}")
            return data
        except (json.JSONDecodeError, OSError) as e:
            log_warn(f"Failed to read marketplace JSON: {e}")
            return None

    @staticmethod
    def get_plugin_description(plugin_name: str, marketplace: str) -> Optional[str]:
        """Get a plugin's description from its marketplace.json."""
        data = CacheManager.read_marketplace_json(marketplace)
        if not data:
            return None
        for p in data.get("plugins", []):
            if p.get("name") == plugin_name:
                return p.get("description")
        return None

    @staticmethod
    def sync_marketplace(marketplace: str) -> int:
        """Import all plugins from a marketplace.json into the cache. Returns count of new/updated."""
        data = CacheManager.read_marketplace_json(marketplace)
        if not data:
            log_warn(f"Could not read marketplace data for '{marketplace}'")
            return 0
        paths = get_cache_paths()
        ensure_cache_dir()
        cache_file = paths["plugins_cache"]
        entries = CacheManager._read_jsonl(cache_file)
        existing_keys = {e.get("key") for e in entries}
        now = datetime.now().isoformat()
        count = 0
        for plugin in data.get("plugins", []):
            name = plugin.get("name")
            if not name:
                continue
            key = f"{name}@{marketplace}"
            desc = plugin.get("description")
            ver = plugin.get("version")
            found = False
            for entry in entries:
                if entry.get("key") == key:
                    found = True
                    updated = False
                    if desc and entry.get("description") != desc:
                        entry["description"] = desc
                        updated = True
                    if ver and entry.get("version") != ver:
                        entry["version"] = ver
                        updated = True
                    if updated:
                        count += 1
                        log_debug(f"Updated metadata: {key}")
                    break
            if not found:
                new_entry: dict[str, Any] = {
                    "plugin": name, "marketplace": marketplace, "key": key,
                    "first_seen": now, "last_used": now,
                    "use_count": 0, "install_count": 0, "invocation_count": 0,
                }
                if desc:
                    new_entry["description"] = desc
                if ver:
                    new_entry["version"] = ver
                entries.append(new_entry)
                count += 1
                log_debug(f"Added from marketplace: {key}")
        CacheManager._write_jsonl(cache_file, entries)
        # Also update marketplace cache
        CacheManager.update_marketplace(marketplace)
        return count


class LogManager:
    """Stateless manager for invocations.jsonl with auto-trim."""

    @staticmethod
    def append(entry: dict) -> None:
        paths = get_cache_paths()
        ensure_cache_dir()
        log_file = paths["invocations_log"]
        line = json.dumps(entry, separators=(",", ":")) + "\n"
        with open(log_file, "a") as f:
            f.write(line)
        log_debug(f"Logged invocation: action={entry.get('action')}")
        LogManager._auto_trim(log_file)

    @staticmethod
    def _auto_trim(log_file: Path) -> None:
        try:
            with open(log_file) as f:
                lines = f.readlines()
        except FileNotFoundError:
            return
        if len(lines) <= LOG_MIN_ENTRIES * 2:
            log_trace(f"Log has {len(lines)} lines, no trim needed (threshold: {LOG_MIN_ENTRIES * 2})")
            return
        log_info(f"Auto-trimming log from {len(lines)} to {LOG_MIN_ENTRIES} entries")
        keep = lines[-LOG_MIN_ENTRIES:]
        tmp_path = log_file.with_suffix(".tmp")
        with open(tmp_path, "w") as f:
            f.writelines(keep)
        os.replace(tmp_path, log_file)

    @staticmethod
    def show(last_n: int = 10) -> list[dict]:
        paths = get_cache_paths()
        log_file = paths["invocations_log"]
        if not log_file.exists():
            return []
        entries = []
        with open(log_file) as f:
            for line in f:
                line = line.strip()
                if line:
                    try:
                        entries.append(json.loads(line))
                    except json.JSONDecodeError:
                        pass
        return entries[-last_n:]

    @staticmethod
    def trim(keep_n: Optional[int] = None, days: Optional[int] = None) -> int:
        paths = get_cache_paths()
        log_file = paths["invocations_log"]
        if not log_file.exists():
            return 0
        with open(log_file) as f:
            lines = f.readlines()
        original_count = len(lines)
        if days is not None:
            cutoff = datetime.now().timestamp() - (days * 86400)
            kept = []
            for line in lines:
                line_s = line.strip()
                if not line_s:
                    continue
                try:
                    entry = json.loads(line_s)
                    ts = datetime.fromisoformat(entry["timestamp"]).timestamp()
                    if ts >= cutoff:
                        kept.append(line)
                except (json.JSONDecodeError, KeyError, ValueError):
                    kept.append(line)
            if keep_n is None and len(kept) < LOG_MIN_ENTRIES:
                kept = lines[-LOG_MIN_ENTRIES:] if len(lines) >= LOG_MIN_ENTRIES else lines
            lines = kept
        if keep_n is not None:
            lines = lines[-keep_n:] if len(lines) > keep_n else lines
        tmp_path = log_file.with_suffix(".tmp")
        with open(tmp_path, "w") as f:
            f.writelines(lines)
        os.replace(tmp_path, log_file)
        return original_count - len(lines)


def build_invocation_entry(
    plugin_key: str, plugin_name: str, marketplace: str, action: str,
    args: argparse.Namespace, project_path: Path, paths: dict,
    backup_paths: list, success: bool, error: Optional[str],
    interactive_answers: dict
) -> dict:
    settings_file = str(paths.get("settings", ""))
    backup_path = str(backup_paths[-1]) if backup_paths else ""
    def resolve(p: str) -> str:
        try:
            return str(Path(p).resolve()) if p else ""
        except (OSError, ValueError):
            return p
    return {
        "timestamp": datetime.now().isoformat(),
        "plugin_key": plugin_key,
        "plugin": plugin_name,
        "marketplace": marketplace,
        "action": action,
        "repo_git_root": str(project_path),
        "repo_git_root_resolved": resolve(str(project_path)),
        "settings_file": settings_file,
        "settings_file_resolved": resolve(settings_file),
        "backup_path": backup_path,
        "backup_path_resolved": resolve(backup_path),
        "scope": getattr(args, 'scope', 'project-local'),
        "argv": sys.argv,
        "dry_run": getattr(args, 'dry_run', False),
        "interactive_answers": interactive_answers,
        "success": success,
        "error": error,
        "version": VERSION,
    }


class ScopeDetector:
    """Detect which scopes have a plugin installed."""

    SCOPE_FILES = {
        "project-local": lambda repo: repo / ".claude" / "settings.local.json",
        "project-shared": lambda repo: repo / ".claude" / "settings.json",
        "user": lambda _: Path.home() / ".claude" / "settings.json",
    }

    SCOPE_SHORTCUTS = {
        "project-local": "local",
        "project-shared": "shared",
        "user": "global",
    }

    @staticmethod
    def detect_installed_scopes(plugin_key: str, repo_path: Path) -> list[dict]:
        results = []
        for scope, path_fn in ScopeDetector.SCOPE_FILES.items():
            settings_file = path_fn(repo_path)
            if not settings_file.exists():
                log_trace(f"Scope {scope}: file not found ({settings_file})")
                continue
            try:
                with open(settings_file) as f:
                    data = json.load(f)
                if data.get("enabledPlugins", {}).get(plugin_key):
                    results.append({
                        "scope": scope, "file": settings_file,
                        "shortcut": ScopeDetector.SCOPE_SHORTCUTS[scope],
                    })
                    log_debug(f"Scope {scope}: plugin enabled")
                else:
                    log_trace(f"Scope {scope}: plugin not in enabledPlugins")
            except (json.JSONDecodeError, IOError) as e:
                log_warn(f"Could not read {settings_file}: {e}")
        return results

    @staticmethod
    def detect_all_installed_plugins(repo_path: Path) -> dict[str, list[str]]:
        plugins: dict[str, list[str]] = {}
        for scope, path_fn in ScopeDetector.SCOPE_FILES.items():
            settings_file = path_fn(repo_path)
            if not settings_file.exists():
                continue
            try:
                with open(settings_file) as f:
                    data = json.load(f)
                for key, enabled in data.get("enabledPlugins", {}).items():
                    if enabled:
                        if key not in plugins:
                            plugins[key] = []
                        plugins[key].append(scope)
            except (json.JSONDecodeError, IOError):
                pass
        return plugins


def get_known_marketplaces() -> list[str]:
    """Get list of known marketplaces from Claude Code config."""
    path = Path.home() / ".claude" / "plugins" / "known_marketplaces.json"
    if not path.exists():
        return []
    try:
        with open(path) as f:
            data = json.load(f)
        return list(data.keys())
    except (json.JSONDecodeError, IOError):
        return []


def find_similar_names(target: str, candidates: list[str], threshold: float = 0.6) -> list[str]:
    """Find similar names using simple character-based similarity."""
    def similarity(a: str, b: str) -> float:
        a, b = a.lower(), b.lower()
        if a == b:
            return 1.0
        if a in b or b in a:
            return 0.8
        common = sum(1 for c in a if c in b)
        return common / max(len(a), len(b))

    similar = []
    for candidate in candidates:
        if similarity(target, candidate) >= threshold:
            similar.append(candidate)
    return similar


def print_banner(plugin_name: str, marketplace: str) -> None:
    plugin_key = f"{plugin_name}@{marketplace}"
    print(color(f"""
╔══════════════════════════════════════════════════════════════════════════════╗
║        CLAUDE CODE PLUGIN INSTALLATION FIX                                   ║
║                                                                              ║
║  Plugin: {plugin_key:<63} ║
║                                                                              ║
║  This script applies a workaround for the plugin installation bug.           ║
║  All files will be backed up before modification.                            ║
╚══════════════════════════════════════════════════════════════════════════════╝
""", Colors.CYAN))


def print_debug_info(error_context: str, locals_snapshot: dict[str, Any]) -> None:
    print(color("""
╔══════════════════════════════════════════════════════════════════════════════╗
║  DEBUG INFORMATION - Please include this when reporting issues               ║
╚══════════════════════════════════════════════════════════════════════════════╝
""", Colors.RED))

    debug_info = {
        "timestamp": datetime.now().isoformat(),
        "python_version": sys.version,
        "platform": sys.platform,
        "cwd": os.getcwd(),
        "error_context": error_context,
        "home": str(Path.home()),
        "relevant_state": {k: str(v) for k, v in locals_snapshot.items() if not k.startswith('_')}
    }

    print("```json")
    print(json.dumps(debug_info, indent=2))
    print("```")
    print(color("""
╔══════════════════════════════════════════════════════════════════════════════╗
║  WHERE TO REPORT                                                             ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  For the UPSTREAM Claude Code bug (plugin name collision):                   ║
║    Comment "me too" or describe your issue at:                               ║
║    https://github.com/anthropics/claude-code/issues/14202                    ║
║                                                                              ║
║  For issues with THIS WORKAROUND SCRIPT:                                     ║
║    https://github.com/shibuido/claude-plugin-install/issues                  ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝
""", Colors.YELLOW))


def ask_confirmation(prompt: str, non_interactive: bool) -> bool:
    if non_interactive:
        log_info(f"Non-interactive mode: auto-confirming '{prompt}'")
        return True
    try:
        response = input(f"\n{color('?', Colors.YELLOW)} {prompt} [y/N]: ").strip().lower()
    except EOFError:
        return False
    return response in ('y', 'yes')


def backup_file(filepath: Path) -> Optional[Path]:
    if not filepath.exists():
        log_debug(f"File does not exist, no backup needed: {filepath}")
        return None

    timestamp = datetime.now().strftime("%Y-%m-%d--%H-%M-%S")
    backup_path = filepath.with_suffix(f"{filepath.suffix}.bak.{timestamp}")

    log_debug(f"Creating backup: {filepath} -> {backup_path}")
    shutil.copy2(filepath, backup_path)
    log_success(f"Backed up: {backup_path}")
    return backup_path


def get_paths(scope: str, project_path: Path, plugin_name: str, marketplace: str) -> dict[str, Path]:
    home = Path.home()
    claude_home = home / ".claude"

    paths = {
        "installed_plugins": claude_home / "plugins" / "installed_plugins.json",
        "known_marketplaces": claude_home / "plugins" / "known_marketplaces.json",
        "plugin_cache": claude_home / "plugins" / "cache" / marketplace / plugin_name,
    }

    if scope == "user":
        paths["settings"] = claude_home / "settings.json"
    elif scope == "project-shared":
        paths["settings"] = project_path / ".claude" / "settings.json"
    else:  # project-local (default)
        paths["settings"] = project_path / ".claude" / "settings.local.json"

    paths["project_claude_dir"] = project_path / ".claude"

    return paths


def verify_assumptions(paths: dict[str, Path], marketplace: str, plugin_name: str) -> tuple[bool, list[str]]:
    errors = []

    log_step("Verifying assumptions...")

    if not paths["installed_plugins"].exists():
        errors.append(f"installed_plugins.json not found at: {paths['installed_plugins']}")
    else:
        log_success(f"Found installed_plugins.json")
        log_debug(f"  Path: {paths['installed_plugins']}")

    if not paths["known_marketplaces"].exists():
        errors.append(f"known_marketplaces.json not found at: {paths['known_marketplaces']}")
    else:
        log_success(f"Found known_marketplaces.json")

        try:
            with open(paths["known_marketplaces"]) as f:
                marketplaces = json.load(f)
            if marketplace not in marketplaces:
                similar = find_similar_names(marketplace, list(marketplaces.keys()))
                err_msg = f"'{marketplace}' not found in known_marketplaces.json."
                if similar:
                    err_msg += f" Did you mean: {', '.join(similar)}?"
                else:
                    err_msg += f" Run: /plugin marketplace add OWNER/{marketplace}"
                errors.append(err_msg)
            else:
                log_success(f"'{marketplace}' is registered")
                log_trace(f"  Config: {json.dumps(marketplaces[marketplace], indent=2)}")
        except json.JSONDecodeError as e:
            errors.append(f"Invalid JSON in known_marketplaces.json: {e}")

    if not paths["plugin_cache"].exists():
        errors.append(f"Plugin cache not found at: {paths['plugin_cache']}. "
                     f"The marketplace may not have been synced. Try: /plugin marketplace add OWNER/{marketplace}")
    else:
        log_success(f"Found plugin cache for '{plugin_name}'")
        versions = list(paths["plugin_cache"].iterdir())
        if versions:
            log_debug(f"  Available versions: {[v.name for v in versions]}")

    return (len(errors) == 0, errors)


def get_plugin_version(paths: dict[str, Path]) -> Optional[str]:
    cache_path = paths["plugin_cache"]
    if not cache_path.exists():
        return None

    versions = sorted(cache_path.iterdir(), key=lambda p: p.stat().st_mtime, reverse=True)
    if versions:
        return versions[0].name
    return None


def check_already_installed(paths: dict[str, Path], project_path: Path, plugin_key: str) -> bool:
    if not paths["installed_plugins"].exists():
        return False

    try:
        with open(paths["installed_plugins"]) as f:
            data = json.load(f)

        if plugin_key not in data.get("plugins", {}):
            return False

        installations = data["plugins"][plugin_key]
        project_str = str(project_path)

        for inst in installations:
            if inst.get("scope") == "user":
                log_warn(f"{plugin_key} is installed at user scope (globally)")
                return True
            if inst.get("projectPath") == project_str:
                log_warn(f"{plugin_key} is already installed for this project")
                return True

        return False
    except (json.JSONDecodeError, KeyError) as e:
        log_debug(f"Error checking installation: {e}")
        return False


def update_installed_plugins(paths: dict[str, Path], project_path: Path, scope: str,
                            plugin_key: str) -> bool:
    filepath = paths["installed_plugins"]

    try:
        with open(filepath) as f:
            data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError) as e:
        log_error(f"Failed to read {filepath}: {e}")
        return False

    version = get_plugin_version(paths) or "unknown"
    now = datetime.now().isoformat()

    new_entry: dict[str, Any] = {
        "installPath": str(paths["plugin_cache"] / version),
        "version": version,
        "installedAt": now,
        "lastUpdated": now,
    }

    if scope == "user":
        new_entry["scope"] = "user"
    else:
        new_entry["scope"] = "local"
        new_entry["projectPath"] = str(project_path)

    if "plugins" not in data:
        data["plugins"] = {}

    if plugin_key not in data["plugins"]:
        data["plugins"][plugin_key] = []

    data["plugins"][plugin_key].append(new_entry)

    log_trace(f"New entry: {json.dumps(new_entry, indent=2)}")

    try:
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)
        log_success(f"Updated {filepath}")
        return True
    except IOError as e:
        log_error(f"Failed to write {filepath}: {e}")
        return False


def update_settings(paths: dict[str, Path], plugin_key: str) -> bool:
    filepath = paths["settings"]

    if filepath.exists():
        try:
            with open(filepath) as f:
                data = json.load(f)
        except json.JSONDecodeError as e:
            log_error(f"Invalid JSON in {filepath}: {e}")
            return False
    else:
        data = {}
        filepath.parent.mkdir(parents=True, exist_ok=True)

    if "enabledPlugins" not in data:
        data["enabledPlugins"] = {}

    data["enabledPlugins"][plugin_key] = True

    log_trace(f"Settings will be: {json.dumps(data, indent=2)}")

    try:
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)
            f.write('\n')
        log_success(f"Updated {filepath}")
        return True
    except IOError as e:
        log_error(f"Failed to write {filepath}: {e}")
        return False


def validate_plugin_arg(plugin_arg: str) -> tuple[Optional[str], Optional[str], Optional[str]]:
    """
    Validate and parse plugin@marketplace argument.
    Returns (plugin_name, marketplace, error_message).
    If error_message is set, the other values are None.
    """
    if "@" not in plugin_arg:
        known = get_known_marketplaces()
        error_lines = [
            f"Invalid plugin format. Expected: plugin@marketplace",
            f"",
            f"You provided: {plugin_arg}",
            f"",
        ]
        if known:
            error_lines.append("Available marketplaces on your system:")
            for m in known:
                error_lines.append(f"  - {m}")
            error_lines.append("")
        error_lines.append(f"Example: ./claude-plugin-install -p {plugin_arg}@MARKETPLACE_NAME")
        return None, None, "\n".join(error_lines)

    parts = plugin_arg.split("@", 1)
    plugin_name = parts[0].strip()
    marketplace = parts[1].strip()

    if not plugin_name:
        return None, None, "Plugin name cannot be empty. Expected: plugin@marketplace"

    if not marketplace:
        return None, None, "Marketplace cannot be empty. Expected: plugin@marketplace"

    # Check if marketplace exists
    known = get_known_marketplaces()
    if known and marketplace not in known:
        similar = find_similar_names(marketplace, known)
        error_lines = [
            f"Marketplace '{marketplace}' not found in your Claude Code configuration.",
            f"",
        ]
        if similar:
            error_lines.append(f"Did you mean: {', '.join(similar)}?")
            error_lines.append("")
        error_lines.append("Available marketplaces:")
        for m in known:
            error_lines.append(f"  - {m}")
        error_lines.append("")
        error_lines.append("To add a new marketplace in Claude Code:")
        error_lines.append(f"  /plugin marketplace add owner/{marketplace}")
        error_lines.append("")
        error_lines.append("If adding the marketplace also fails and needs a workaround,")
        error_lines.append("please file a feature request: https://github.com/shibuido/claude-plugin-install/issues")
        return None, None, "\n".join(error_lines)

    return plugin_name, marketplace, None


class MenuHandler:
    """Interactive menu for plugin management."""

    @staticmethod
    def _detect_fuzzy_finder() -> Optional[str]:
        """Detect available fuzzy finder: sk -> fzf -> None."""
        if shutil.which("sk"):
            return "sk"
        if shutil.which("fzf"):
            return "fzf"
        return None

    @staticmethod
    def _build_menu_items(repo_path: Path) -> list[dict]:
        """Build sorted list of dicts representing all plugins for the interactive menu.

        Returns a list of dicts, each with keys:
            idx, key, tag, installed, scopes, description, use_count, last_used, line

        Sorting order:
            1. Installed plugins (alphabetical by key)
            2. Previously-used plugins (use_count > 0, by use_count desc, last_used desc)
            3. Never-used plugins (use_count == 0, alphabetical by key)
        """
        KEY_WIDTH = 48
        DESC_MAX = 60

        installed = ScopeDetector.detect_all_installed_plugins(repo_path)
        cached = CacheManager.list_plugins()

        # Build a lookup from cache keyed by plugin key
        cache_by_key: dict[str, dict] = {}
        for entry in cached:
            cache_by_key[entry["key"]] = entry

        # --- Group 1: Installed plugins, alphabetical ---
        group_installed: list[dict] = []
        for key in sorted(installed.keys()):
            ce = cache_by_key.get(key, {})
            group_installed.append({
                "key": key,
                "tag": "i",
                "installed": True,
                "scopes": installed[key],
                "description": ce.get("description", ""),
                "use_count": ce.get("use_count", 0),
                "last_used": ce.get("last_used", ""),
            })

        # --- Available (not installed) plugins from cache ---
        available = [
            e for e in cached if e["key"] not in installed
        ]
        # Group 2: previously used (use_count > 0)
        def _safe_ts(val: str) -> float:
            """Parse ISO timestamp to epoch float, returning 0 on failure."""
            try:
                return datetime.fromisoformat(val).timestamp() if val else 0
            except (ValueError, TypeError):
                return 0

        group_used = sorted(
            [e for e in available if e.get("use_count", 0) > 0],
            key=lambda e: (-(e.get("use_count", 0)),
                           -_safe_ts(e.get("last_used", ""))),
        )
        # Group 3: never used (use_count == 0)
        group_never = sorted(
            [e for e in available if e.get("use_count", 0) == 0],
            key=lambda e: e["key"],
        )

        # Convert groups 2 and 3 into the common dict format
        def _avail_dict(entry: dict) -> dict:
            return {
                "key": entry["key"],
                "tag": "a",
                "installed": False,
                "scopes": [],
                "description": entry.get("description", ""),
                "use_count": entry.get("use_count", 0),
                "last_used": entry.get("last_used", ""),
            }

        all_items: list[dict] = (
            group_installed
            + [_avail_dict(e) for e in group_used]
            + [_avail_dict(e) for e in group_never]
        )

        total = len(all_items)
        idx_width = len(str(total)) if total else 1

        # Assign idx and build display line
        for i, item in enumerate(all_items, start=1):
            item["idx"] = i

            tag = item["tag"]
            num_str = str(i).rjust(idx_width)

            # Tag color: green for installed, blue for available
            if tag == "i":
                tag_color = Colors.GREEN
            else:
                tag_color = Colors.BLUE
            tag_part = color(f"{num_str}{tag}.", tag_color)

            # Key padded to align :: separators
            padded_key = item["key"].ljust(KEY_WIDTH)

            # Description, truncated if needed
            desc = item["description"]
            if len(desc) > DESC_MAX:
                desc = desc[:DESC_MAX - 3] + "..."
            if desc:
                desc_part = f" {Colors.DIM}::{Colors.RESET} {color(desc, Colors.CYAN)}"
            else:
                desc_part = ""

            item["line"] = f"{tag_part} {padded_key}{desc_part}"

        return all_items

    @staticmethod
    def _menu_fuzzy(items: list[dict], finder: str, repo_path: Path) -> Optional[list[dict]]:
        """Run sk/fzf with multi-select, return selected items."""
        input_text = "\n".join(item["line"] for item in items)

        cmd = [
            finder, "-m",
            "--ansi",
            "--reverse",
            "--prompt", "Plugin> ",
            "--header", "TAB=toggle  ENTER=confirm  ESC=quit",
        ]

        result = subprocess.run(cmd, input=input_text, capture_output=True, text=True)

        if result.returncode != 0 or not result.stdout.strip():
            return None

        selected_lines = [line.strip() for line in result.stdout.strip().split("\n") if line.strip()]

        matched: list[dict] = []
        for sel in selected_lines:
            for item in items:
                if item["line"].strip() == sel:
                    matched.append(item)
                    break

        return matched if matched else None

    @staticmethod
    def _menu_fallback(items: list[dict], repo_path: Path) -> Optional[list[dict]]:
        """Fallback numbered menu with threshold and comma multi-select."""
        print(f"\n{color('Plugin Manager', Colors.CYAN)} | Repo: {color(str(repo_path), Colors.BOLD)}\n")

        # --- Installed plugins (tag == "i") -- always shown, no limit ---
        installed_items = [it for it in items if it["tag"] == "i"]
        if installed_items:
            print(color("-- Installed plugins --------------------------", Colors.GREEN))
            for it in installed_items:
                scope_str = ", ".join(
                    ScopeDetector.SCOPE_SHORTCUTS.get(s, s) for s in it["scopes"]
                )
                print(f"  [{it['idx']}] {color(it['key'], Colors.BOLD)}  ({scope_str})")
            print()

        # --- Available plugins (tag == "a") -- limited by threshold ---
        available_items = [it for it in items if it["tag"] == "a"]
        try:
            limit = int(os.environ.get("CPI_MENU_LIMIT", MENU_LIMIT_DEFAULT))
        except (ValueError, TypeError):
            limit = MENU_LIMIT_DEFAULT
        limit = max(1, limit)

        if available_items:
            print(color("-- Available plugins --------------------------", Colors.BLUE))
            shown = available_items[:limit]
            for it in shown:
                # Build metadata string with "ago" calculation
                count = it.get("use_count", 0)
                last_used = it.get("last_used", "")
                try:
                    from_dt = datetime.fromisoformat(last_used)
                    delta = datetime.now() - from_dt
                    if delta.days == 0:
                        ago = "today"
                    elif delta.days == 1:
                        ago = "1d ago"
                    elif delta.days < 7:
                        ago = f"{delta.days}d ago"
                    elif delta.days < 30:
                        ago = f"{delta.days // 7}w ago"
                    else:
                        ago = f"{delta.days // 30}mo ago"
                except (ValueError, TypeError):
                    ago = "?"
                metadata = f"last: {ago}, {count} installs"
                print(f"  [{it['idx']}] {it['key']}  ({metadata})")
                desc = it.get("description", "")
                if desc:
                    print(f"       {color(desc, Colors.CYAN)}")

            remaining = len(available_items) - limit
            if remaining > 0:
                print(f"  ... and {remaining} more plugins. Install sk or fzf for fuzzy search.")
            print()

        if not installed_items and not available_items:
            print("  No installed or remembered plugins.")
            print("  Type a plugin@marketplace to install, or 'q' to quit.\n")

        # --- Prompt for input ---
        if items:
            prompt_text = f"Select [1-{items[-1]['idx']}], comma-separate for multiple (q=quit): "
        else:
            prompt_text = "Type plugin@marketplace (q=quit): "
        try:
            choice = input(prompt_text).strip()
        except (EOFError, KeyboardInterrupt):
            print()
            return None

        if not choice or choice.lower() == "q":
            return None

        # --- Parse input ---
        # Text with @: treat as typed plugin key
        if "@" in choice and not choice.replace(",", "").replace(" ", "").isdigit():
            return [{"key": choice.strip(), "installed": False, "typed": True}]

        # Try parsing as comma-separated numbers
        try:
            nums = [int(n.strip()) for n in choice.split(",") if n.strip()]
        except ValueError:
            print(f"Invalid input. Use numbers or plugin@marketplace format.")
            return None

        if not nums:
            return None

        # Build lookup by idx
        by_idx = {it["idx"]: it for it in items}
        matched: list[dict] = []
        for n in nums:
            if n in by_idx:
                matched.append(by_idx[n])
            else:
                print(f"Invalid selection: {n}")
                return None

        return matched if matched else None

    @staticmethod
    def display_menu(repo_path: Path) -> Optional[list[dict]]:
        """Display interactive menu, return selected item(s)."""
        items = MenuHandler._build_menu_items(repo_path)
        if not items:
            print("  No plugins available. Run: cache sync")
            return None

        finder = MenuHandler._detect_fuzzy_finder()
        if finder:
            return MenuHandler._menu_fuzzy(items, finder, repo_path)
        else:
            return MenuHandler._menu_fallback(items, repo_path)


def cmd_interactive_menu(args) -> int:
    """Interactive menu when no -p plugin is provided."""
    project_path = args.project_path.resolve()
    selections = MenuHandler.display_menu(project_path)
    if not selections:
        return 0

    # Single selection - keep current behavior
    if len(selections) == 1:
        sel = selections[0]
        plugin_key = sel["key"]

        if sel.get("installed"):
            # Installed plugin: offer uninstall
            scopes = sel.get("scopes", [])
            print(f"\n{color('Selected:', Colors.BOLD)} {plugin_key}")
            print(f"Currently installed in: {', '.join(scopes)}")
            if ask_confirmation("Uninstall from all scopes?", getattr(args, 'non_interactive', False)):
                iter_args = argparse.Namespace(**vars(args))
                iter_args.plugin = plugin_key
                iter_args.all_scopes = True
                iter_args.subcommand = "uninstall"
                return cmd_uninstall(iter_args)
            return 0
        else:
            # Available plugin: install it
            _, _, error = validate_plugin_arg(plugin_key)
            if error:
                log_error(error)
                return 1
            iter_args = argparse.Namespace(**vars(args))
            iter_args.plugin = plugin_key
            return cmd_install(iter_args)

    # Multi-select
    installed_sels = [s for s in selections if s.get("installed")]
    available_sels = [s for s in selections if not s.get("installed")]

    failures = 0

    if available_sels:
        print(f"\n{color('Installing', Colors.BOLD)} {len(available_sels)} plugin(s):")
        for sel in available_sels:
            print(f"  - {sel['key']}")
        if not ask_confirmation("Proceed?", getattr(args, 'non_interactive', False)):
            return 0
        for sel in available_sels:
            _, _, error = validate_plugin_arg(sel["key"])
            if error:
                log_error(error)
                failures += 1
                continue
            iter_args = argparse.Namespace(**vars(args))
            iter_args.plugin = sel["key"]
            ret = cmd_install(iter_args)
            if ret != 0:
                failures += 1

    if installed_sels:
        print(f"\n{color('Selected installed plugins:', Colors.BOLD)}")
        for sel in installed_sels:
            print(f"  - {sel['key']}  ({', '.join(sel.get('scopes', []))})")
        if ask_confirmation("Uninstall all selected from all scopes?", getattr(args, 'non_interactive', False)):
            for sel in installed_sels:
                iter_args = argparse.Namespace(**vars(args))
                iter_args.plugin = sel["key"]
                iter_args.all_scopes = True
                iter_args.subcommand = "uninstall"
                ret = cmd_uninstall(iter_args)
                if ret != 0:
                    failures += 1

    return 1 if failures else 0


def cmd_install(args) -> int:
    """Install a plugin (extracted from old main)."""
    plugin_name, marketplace, error = validate_plugin_arg(args.plugin)
    if error:
        log_error(error)
        return 1

    plugin_key = f"{plugin_name}@{marketplace}"

    # Print banner
    print_banner(plugin_name, marketplace)

    project_path = args.project_path.resolve()
    scope = getattr(args, 'scope', 'project-local')
    paths = get_paths(scope, project_path, plugin_name, marketplace)

    log_info(f"Plugin: {plugin_key}")
    log_info(f"Project path: {project_path}")
    log_info(f"Scope: {scope}")
    log_debug(f"Paths: {', '.join(f'{k}={v}' for k, v in paths.items())}")
    log_trace(f"Verbosity level: {VERBOSITY}")

    dry_run = getattr(args, 'dry_run', False)
    non_interactive = getattr(args, 'non_interactive', False)

    if dry_run:
        log_warn("DRY RUN MODE - No changes will be made")

    # === IMPORTANT WARNING ===
    log_step("Pre-flight checks")
    print(color("""
┌──────────────────────────────────────────────────────────────────────────────┐
│  IMPORTANT: Please close Claude Code in this directory before proceeding     │
│                                                                              │
│  This script modifies .claude/settings files. If Claude Code is running,     │
│  there may be a race condition where your changes get overwritten.           │
│                                                                              │
│  To close Claude Code:                                                       │
│    - In the Claude Code TUI, type /exit or press Ctrl+C                      │
│    - Or close the terminal/tmux pane running Claude Code                     │
│                                                                              │
│  Don't worry - all files will be backed up before any modifications!         │
└──────────────────────────────────────────────────────────────────────────────┘
""", Colors.YELLOW))

    if not ask_confirmation("Have you closed Claude Code in this directory?", non_interactive):
        print("Please close Claude Code and run this script again.")
        return 0

    # === VERIFY ASSUMPTIONS ===
    success, errors = verify_assumptions(paths, marketplace, plugin_name)

    if not success:
        log_error("Assumption verification failed!")
        for err in errors:
            log_error(f"  - {err}")
        print_debug_info("Assumption verification failed", {
            "paths": {k: str(v) for k, v in paths.items()},
            "errors": errors,
            "project_path": str(project_path),
            "scope": scope,
            "plugin_key": plugin_key,
        })
        return 1

    # === CHECK IF ALREADY INSTALLED ===
    log_step("Checking current installation status")

    if check_already_installed(paths, project_path, plugin_key):
        if not ask_confirmation("Plugin appears to be already installed. Continue anyway?", non_interactive):
            print("Exiting without changes.")
            return 0
    else:
        log_success("Plugin not yet installed for this project/scope")

    # === SHOW WHAT WILL BE MODIFIED ===
    log_step("Files to be modified")

    files_to_modify = [
        paths["installed_plugins"],
        paths["settings"],
    ]

    for f in files_to_modify:
        status = "exists" if f.exists() else "will be created"
        print(f"  - {f} ({status})")

    if dry_run:
        print("DRY RUN: Would modify the above files")
        desc = CacheManager.get_plugin_description(plugin_name, marketplace)
        ver = get_plugin_version(paths)
        CacheManager.update_plugin(plugin_name, marketplace, success=False, description=desc, version=ver)
        CacheManager.update_marketplace(marketplace)
        log_entry = build_invocation_entry(
            plugin_key=plugin_key, plugin_name=plugin_name, marketplace=marketplace,
            action="install", args=args, project_path=project_path, paths=paths,
            backup_paths=[], success=True, error=None,
            interactive_answers={"dry_run": True}
        )
        LogManager.append(log_entry)
        return 0

    if not ask_confirmation("Proceed with modifications?", non_interactive):
        print("Exiting without changes.")
        return 0

    # === CREATE BACKUPS ===
    log_step("Creating backups")

    backups = []
    for f in files_to_modify:
        backup = backup_file(f)
        if backup:
            backups.append(backup)

    if not backups:
        log_info("No existing files to back up")

    # === APPLY MODIFICATIONS ===
    log_step("Applying modifications")

    log_info("Updating installed_plugins.json...")
    if not update_installed_plugins(paths, project_path, scope, plugin_key):
        log_error("Failed to update installed_plugins.json")
        print_debug_info("Failed to update installed_plugins.json", {
            "paths": {k: str(v) for k, v in paths.items()},
            "project_path": str(project_path),
            "scope": scope,
            "plugin_key": plugin_key,
        })
        return 1

    log_info(f"Updating {paths['settings'].name}...")
    if not update_settings(paths, plugin_key):
        log_error(f"Failed to update {paths['settings']}")
        print_debug_info("Failed to update settings", {
            "paths": {k: str(v) for k, v in paths.items()},
            "project_path": str(project_path),
            "scope": scope,
            "plugin_key": plugin_key,
        })
        return 1

    # === SUCCESS ===
    print(color("""
╔══════════════════════════════════════════════════════════════════════════════╗
║  SUCCESS! Plugin installation workaround applied.                            ║
╚══════════════════════════════════════════════════════════════════════════════╝
""", Colors.GREEN))

    print("Next steps:")
    print(f"  1. Start Claude Code in this directory: {color('claude', Colors.CYAN)}")
    print(f"  2. Run {color('/plugin', Colors.CYAN)} and check the Installed tab")
    print(f"  3. You should see: {color(f'{plugin_name} Plugin · {marketplace} · enabled', Colors.GREEN)}")

    if backups:
        print(f"\nBackups created:")
        for b in backups:
            print(f"  - {b}")

    # === UPDATE CACHE & LOG ===
    desc = CacheManager.get_plugin_description(plugin_name, marketplace)
    ver = get_plugin_version(paths)
    CacheManager.update_plugin(plugin_name, marketplace, success=True, description=desc, version=ver)
    CacheManager.update_marketplace(marketplace)
    log_entry = build_invocation_entry(
        plugin_key=plugin_key, plugin_name=plugin_name, marketplace=marketplace,
        action="install", args=args, project_path=project_path, paths=paths,
        backup_paths=backups, success=True, error=None,
        interactive_answers={}
    )
    LogManager.append(log_entry)

    return 0


def cmd_uninstall(args) -> int:
    """Uninstall a plugin from one or more scopes."""
    plugin_arg = args.plugin
    plugin_name, marketplace, error = validate_plugin_arg(plugin_arg)
    if error:
        log_error(error)
        return 1
    plugin_key = f"{plugin_name}@{marketplace}"
    project_path = args.project_path.resolve()

    scopes = ScopeDetector.detect_installed_scopes(plugin_key, project_path)
    if not scopes:
        log_warn(f"{plugin_key} is not installed in any scope for {project_path}")
        return 0

    non_interactive = getattr(args, 'non_interactive', False)
    scope_shortcut = getattr(args, 'scope_shortcut', None)

    if getattr(args, "all_scopes", False):
        target_scopes = scopes
    elif scope_shortcut:
        target_scopes = [s for s in scopes if s["scope"] == scope_shortcut]
        if not target_scopes:
            log_warn(f"{plugin_key} is not installed in scope {scope_shortcut}")
            return 0
    elif non_interactive:
        log_error("Non-interactive uninstall requires -l, -g, -r, or --all")
        return 1
    else:
        # Interactive scope selection
        print(f"\n{color('Uninstall:', Colors.BOLD)} {plugin_key}")
        print("Found in scopes:")
        for i, s in enumerate(scopes, 1):
            print(f"  [{i}] {s['shortcut']}  ({s['file']})")
        print(f"  [a] All scopes")
        try:
            choice = input(f"\nUninstall from (numbers/a): ").strip().lower()
        except (EOFError, KeyboardInterrupt):
            print()
            return 0
        if choice == "a":
            target_scopes = scopes
        else:
            target_scopes = []
            for c in choice.split(","):
                c = c.strip()
                try:
                    i = int(c) - 1
                    if 0 <= i < len(scopes):
                        target_scopes.append(scopes[i])
                except ValueError:
                    pass
        if not target_scopes:
            print("No scopes selected, exiting.")
            return 0

    backup_paths = []
    for scope_info in target_scopes:
        settings_file = scope_info["file"]
        log_info(f"Removing {plugin_key} from {scope_info['shortcut']} ({settings_file})")
        backup = backup_file(settings_file)
        if backup:
            backup_paths.append(backup)
        try:
            with open(settings_file) as f:
                data = json.load(f)
            if plugin_key in data.get("enabledPlugins", {}):
                del data["enabledPlugins"][plugin_key]
                with open(settings_file, "w") as f:
                    json.dump(data, f, indent=2)
                    f.write("\n")
                log_success(f"Removed from {scope_info['shortcut']}")
            else:
                log_warn(f"Not found in {scope_info['shortcut']} (already removed?)")
        except (json.JSONDecodeError, IOError) as e:
            log_error(f"Failed to update {settings_file}: {e}")
            return 1

    # Clean installed_plugins.json if no scopes remain
    remaining = ScopeDetector.detect_installed_scopes(plugin_key, project_path)
    if not remaining:
        installed_plugins = Path.home() / ".claude" / "plugins" / "installed_plugins.json"
        if installed_plugins.exists():
            try:
                backup = backup_file(installed_plugins)
                if backup:
                    backup_paths.append(backup)
                with open(installed_plugins) as f:
                    data = json.load(f)
                if plugin_key in data.get("plugins", {}):
                    entries = data["plugins"][plugin_key]
                    entries = [e for e in entries if e.get("projectPath") != str(project_path)]
                    if entries:
                        data["plugins"][plugin_key] = entries
                    else:
                        del data["plugins"][plugin_key]
                    with open(installed_plugins, "w") as f:
                        json.dump(data, f, indent=2)
                    log_success("Cleaned up installed_plugins.json")
            except (json.JSONDecodeError, IOError) as e:
                log_warn(f"Could not clean installed_plugins.json: {e}")

    log_entry = build_invocation_entry(
        plugin_key=plugin_key, plugin_name=plugin_name, marketplace=marketplace,
        action="uninstall", args=args, project_path=project_path,
        paths={"settings": str(target_scopes[0]["file"]) if target_scopes else ""},
        backup_paths=backup_paths, success=True, error=None,
        interactive_answers={},
    )
    LogManager.append(log_entry)
    CacheManager.update_plugin(plugin_name, marketplace, success=False)

    print(color(f"\nUninstalled {plugin_key}", Colors.GREEN))
    return 0


def cmd_cache(args) -> int:
    """Manage plugin memory cache."""
    action = getattr(args, "cache_action", None)
    if action == "list":
        entries = CacheManager.list_plugins()
        if not entries:
            print("No remembered plugins.")
            return 0
        for e in entries:
            desc = e.get("description", "")
            ver = e.get("version", "")
            ver_str = f" v{ver}" if ver else ""
            line = f"  {e['key']}{ver_str}  (installs: {e.get('install_count', 0)}, last: {e.get('last_used', '?')[:10]})"
            print(line)
            if desc:
                print(f"    {color(desc, Colors.CYAN)}")
        return 0
    elif action == "list-marketplaces":
        entries = CacheManager.list_marketplaces()
        if not entries:
            print("No remembered marketplaces.")
            return 0
        for e in entries:
            print(f"  {e['marketplace']}  (last: {e.get('last_used', '?')[:10]})")
        return 0
    elif action == "sync":
        marketplace = getattr(args, "marketplace", None)
        if not marketplace:
            # Sync all known marketplaces
            known_mp_path = Path.home() / ".claude" / "plugins" / "known_marketplaces.json"
            if not known_mp_path.exists():
                log_warn("No known marketplaces found")
                return 1
            with open(known_mp_path) as f:
                known = json.load(f)
            total = 0
            for mp_name in known:
                count = CacheManager.sync_marketplace(mp_name)
                print(f"  {mp_name}: {count} plugins added/updated")
                total += count
            log_success(f"Synced {total} plugins from {len(known)} marketplace(s)")
            return 0
        count = CacheManager.sync_marketplace(marketplace)
        log_success(f"Synced {count} plugins from {marketplace}")
        return 0
    elif action == "remove":
        if CacheManager.remove_plugin(args.plugin):
            log_success(f"Removed {args.plugin} from plugin memory")
        else:
            log_warn(f"{args.plugin} not found in plugin memory")
        return 0
    elif action == "clear":
        CacheManager.clear()
        log_success("Plugin memory cleared")
        return 0
    else:
        print("Usage: claude-plugin-install cache {list|list-marketplaces|sync|remove|clear}")
        return 1


def cmd_log(args) -> int:
    """Manage invocation log."""
    action = getattr(args, "log_action", None)
    if action == "show":
        entries = LogManager.show(args.last)
        if not entries:
            print("No invocation history.")
            return 0
        for e in entries:
            ts = e.get("timestamp", "?")[:19]
            key = e.get("plugin_key", "?")
            act = e.get("action", "?")
            ok = "ok" if e.get("success") else "err"
            print(f"  {ts}  {ok} {act:10s} {key}")
        return 0
    elif action == "trim":
        removed = LogManager.trim(keep_n=getattr(args, "keep", None), days=getattr(args, "days", None))
        log_success(f"Trimmed {removed} entries from invocation log")
        return 0
    else:
        print("Usage: claude-plugin-install log {show|trim}")
        return 1


def build_parser() -> argparse.ArgumentParser:
    """Build the argument parser with subcommands."""
    parser = argparse.ArgumentParser(
        description="claude-plugin-install -- Install, manage, and remember Claude Code plugins",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EXAMPLES:
  claude-plugin-install                                         # interactive menu
  claude-plugin-install -p superpowers@superpowers-marketplace  # install
  claude-plugin-install -p superpowers@superpowers-marketplace -y  # non-interactive
  claude-plugin-install uninstall superpowers@superpowers-marketplace
  claude-plugin-install cache list
  claude-plugin-install log show --last 20

SCOPE OPTIONS:
  project-local   Current user in this project (default). Uses: .claude/settings.local.json
  project-shared  All users of this project. Uses: .claude/settings.json (committed)
  user            All projects for current user. Uses: ~/.claude/settings.json

RELATED ISSUES:
  https://github.com/anthropics/claude-code/issues/20593
  https://github.com/anthropics/claude-code/issues/14202
"""
    )

    # Global flags
    parser.add_argument("-v", "--verbose", action="count", default=0,
                        help="Increase verbosity (-v=INFO, -vv=DEBUG, -vvv=TRACE)")
    parser.add_argument("-d", "--project-path", type=Path, default=Path.cwd(),
                        help="Project path (default: current directory)")

    # Install flags (for default/no-subcommand mode)
    parser.add_argument("-p", "--plugin", metavar="PLUGIN@MARKETPLACE",
                        help="Plugin to install (e.g., superpowers@superpowers-marketplace)")
    parser.add_argument("-y", "--yes", "--non-interactive", dest="non_interactive",
                        action="store_true", help="Non-interactive mode")
    parser.add_argument("-n", "--dry-run", action="store_true", help="Preview changes only")
    parser.add_argument("-s", "--scope", choices=["project-local", "project-shared", "user"],
                        default="project-local", help="Installation scope (default: project-local)")
    parser.add_argument("-l", dest="scope_shortcut", action="store_const",
                        const="project-local", help="Shortcut: project-local scope")
    parser.add_argument("-g", dest="scope_shortcut", action="store_const",
                        const="user", help="Shortcut: user/global scope")
    parser.add_argument("-r", dest="scope_shortcut", action="store_const",
                        const="project-shared", help="Shortcut: project-shared/repo scope")

    subparsers = parser.add_subparsers(dest="subcommand")

    # uninstall subcommand
    unsub = subparsers.add_parser("uninstall", help="Uninstall a plugin")
    unsub.add_argument("plugin", metavar="PLUGIN@MARKETPLACE", help="Plugin to uninstall")
    unsub.add_argument("-y", "--yes", dest="non_interactive", action="store_true")
    unsub.add_argument("-d", "--project-path", type=Path, default=Path.cwd())
    unsub.add_argument("-v", "--verbose", action="count", default=0)
    unsub.add_argument("-l", dest="scope_shortcut", action="store_const", const="project-local")
    unsub.add_argument("-g", dest="scope_shortcut", action="store_const", const="user")
    unsub.add_argument("-r", dest="scope_shortcut", action="store_const", const="project-shared")
    unsub.add_argument("--all", dest="all_scopes", action="store_true", help="Uninstall from all scopes")

    # cache subcommand
    cachesub = subparsers.add_parser("cache", help="Manage plugin memory cache")
    cache_sub = cachesub.add_subparsers(dest="cache_action")
    cache_sub.add_parser("list", help="List remembered plugins")
    cache_sub.add_parser("list-marketplaces", help="List remembered marketplaces")
    cache_sync = cache_sub.add_parser("sync", help="Import plugins from marketplace(s) into cache")
    cache_sync.add_argument("marketplace", nargs="?", default=None,
                            help="Marketplace to sync (default: all known marketplaces)")
    cache_rm = cache_sub.add_parser("remove", help="Forget a plugin")
    cache_rm.add_argument("plugin", metavar="PLUGIN@MARKETPLACE")
    cache_sub.add_parser("clear", help="Clear all plugin memory")

    # log subcommand
    logsub = subparsers.add_parser("log", help="Manage invocation log")
    log_sub = logsub.add_subparsers(dest="log_action")
    log_show = log_sub.add_parser("show", help="Show recent invocations")
    log_show.add_argument("--last", type=int, default=10, help="Number of entries")
    log_trim = log_sub.add_parser("trim", help="Trim log entries")
    log_trim.add_argument("--keep", type=int, help="Keep last N entries")
    log_trim.add_argument("--days", type=int, help="Keep entries from last N days")

    return parser


def check_on_path() -> None:
    """Check if the tool is available on PATH. If not, offer to install it."""
    if shutil.which("claude-plugin-install"):
        return
    script_path = Path(__file__).resolve()
    # Common user-local bin directories
    candidates = [
        Path.home() / ".local" / "bin",
        Path.home() / "bin",
    ]
    target_dir = None
    for d in candidates:
        if d.exists() and str(d) in os.environ.get("PATH", ""):
            target_dir = d
            break
    if target_dir is None:
        target_dir = candidates[0]  # default to ~/.local/bin
    link_path = target_dir / "claude-plugin-install"
    print(f"\n{color('TIP:', Colors.YELLOW)} claude-plugin-install is not on your PATH.", file=sys.stderr)
    print(f"  To make it available everywhere, run:", file=sys.stderr)
    print(f"    mkdir -p {target_dir} && ln -sf {script_path} {link_path}", file=sys.stderr)
    if str(target_dir) not in os.environ.get("PATH", ""):
        print(f"    export PATH=\"{target_dir}:$PATH\"  # add to ~/.bashrc or ~/.zshrc", file=sys.stderr)
    try:
        answer = input(f"\n  Install now? [Y/n] ").strip().lower()
    except (EOFError, KeyboardInterrupt):
        print(file=sys.stderr)
        return
    if answer in ("", "y", "yes"):
        target_dir.mkdir(parents=True, exist_ok=True)
        try:
            link_path.unlink(missing_ok=True)
            link_path.symlink_to(script_path)
            print(f"  {color('Done!', Colors.GREEN)} Symlinked {link_path} -> {script_path}", file=sys.stderr)
            if str(target_dir) not in os.environ.get("PATH", ""):
                print(f"  {color('Note:', Colors.YELLOW)} Add {target_dir} to your PATH to use it.", file=sys.stderr)
        except OSError as e:
            print(f"  {color('ERROR:', Colors.RED)} Failed to create symlink: {e}", file=sys.stderr)
    print(file=sys.stderr)


def main() -> int:
    parser = build_parser()
    args = parser.parse_args()

    global VERBOSITY
    VERBOSITY = args.verbose

    # Resolve scope shortcut
    if getattr(args, "scope_shortcut", None):
        args.scope = args.scope_shortcut

    # Check if tool is on PATH (only for interactive use)
    if sys.stdin.isatty() and not getattr(args, "non_interactive", False):
        check_on_path()

    ensure_cache_dir()

    # Route to subcommand handlers
    if args.subcommand == "uninstall":
        return cmd_uninstall(args)
    elif args.subcommand == "cache":
        return cmd_cache(args)
    elif args.subcommand == "log":
        return cmd_log(args)
    elif args.plugin:
        return cmd_install(args)
    else:
        return cmd_interactive_menu(args)


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nInterrupted by user")
        sys.exit(130)
    except Exception as e:
        log_error(f"Unexpected error: {e}")
        import traceback
        print_debug_info(f"Unexpected exception: {e}", {
            "traceback": traceback.format_exc(),
        })
        sys.exit(1)
