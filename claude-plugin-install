#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = []
# ///
"""
claude-plugin-install - Install, manage, and remember Claude Code plugins

Workaround for Claude Code bug where plugin installation fails when a plugin
with the same name exists in multiple marketplaces.

Usage:
    ./claude-plugin-install                                         # interactive menu
    ./claude-plugin-install -p plugin@marketplace [options]         # install
    ./claude-plugin-install uninstall plugin@marketplace [options]  # uninstall
    ./claude-plugin-install cache list                              # list remembered plugins
    ./claude-plugin-install log show --last 20                     # show recent invocations

Examples:
    ./claude-plugin-install -p superpowers@superpowers-marketplace
    ./claude-plugin-install -p superpowers@superpowers-marketplace -y  # non-interactive
    ./claude-plugin-install -p superpowers@superpowers-marketplace -n  # dry-run
    ./claude-plugin-install uninstall superpowers@superpowers-marketplace -l -y

Upstream issues:
    https://github.com/anthropics/claude-code/issues/20593
    https://github.com/anthropics/claude-code/issues/14202
"""

import argparse
import json
import os
import shutil
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Optional


class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    MAGENTA = "\033[95m"
    CYAN = "\033[96m"


# Module-level verbosity: 0=quiet, 1=info(-v), 2=debug(-vv), 3=trace(-vvv)
VERBOSITY = 0


def color(text: str, c: str) -> str:
    return f"{c}{text}{Colors.RESET}"


def log_info(msg: str) -> None:
    """Shown at -v (VERBOSITY >= 1). Printed to stderr."""
    if VERBOSITY >= 1:
        print(f"{color('INFO:', Colors.BLUE)} {msg}", file=sys.stderr)


def log_debug(msg: str) -> None:
    """Shown at -vv (VERBOSITY >= 2). Printed to stderr."""
    if VERBOSITY >= 2:
        print(f"{color('DEBUG:', Colors.MAGENTA)} {msg}", file=sys.stderr)


def log_trace(msg: str) -> None:
    """Shown at -vvv (VERBOSITY >= 3). Printed to stderr."""
    if VERBOSITY >= 3:
        print(f"{color('TRACE:', Colors.CYAN)} {msg}", file=sys.stderr)


def log_success(msg: str) -> None:
    print(f"{color('[OK]', Colors.GREEN)} {msg}")


def log_warn(msg: str) -> None:
    print(f"{color('WARNING:', Colors.YELLOW)} {msg}", file=sys.stderr)


def log_error(msg: str) -> None:
    print(f"{color('ERROR:', Colors.RED)} {msg}", file=sys.stderr)


def log_step(msg: str) -> None:
    print(f"\n{color('▶', Colors.CYAN)} {color(msg, Colors.BOLD)}")


# === Constants & Paths ===
VERSION = "0.2.0"
LOG_MIN_ENTRIES = 1000


def get_cache_dir() -> Path:
    """Get cache directory, respecting XDG_CACHE_HOME."""
    base = Path(os.environ.get("XDG_CACHE_HOME", str(Path.home() / ".cache")))
    return base / "shibuido" / "claude-plugin-install"


def get_cache_paths() -> dict[str, Path]:
    """Get all cache file paths."""
    cache_dir = get_cache_dir()
    return {
        "cache_dir": cache_dir,
        "plugins_cache": cache_dir / "plugins-cache.jsonl",
        "marketplace_cache": cache_dir / "marketplace-cache.jsonl",
        "invocations_log": cache_dir / "invocations.jsonl",
    }


def ensure_cache_dir() -> Path:
    """Create cache directory if it doesn't exist. Returns the path."""
    cache_dir = get_cache_dir()
    cache_dir.mkdir(parents=True, exist_ok=True)
    log_trace(f"Cache directory: {cache_dir}")
    return cache_dir


class CacheManager:
    """Stateless manager for plugins-cache.jsonl and marketplace-cache.jsonl."""

    @staticmethod
    def _read_jsonl(path: Path) -> list[dict]:
        if not path.exists():
            return []
        entries = []
        with open(path) as f:
            for line in f:
                line = line.strip()
                if line:
                    try:
                        entries.append(json.loads(line))
                    except json.JSONDecodeError:
                        log_warn(f"Skipping invalid JSON line in {path}")
        log_trace(f"Read {len(entries)} entries from {path}")
        return entries

    @staticmethod
    def _write_jsonl(path: Path, entries: list[dict]) -> None:
        log_trace(f"Writing {len(entries)} entries to {path}")
        tmp_path = path.with_suffix(".tmp")
        with open(tmp_path, "w") as f:
            for entry in entries:
                f.write(json.dumps(entry, separators=(",", ":")) + "\n")
        os.replace(tmp_path, path)
        log_debug(f"Wrote {path}")

    @staticmethod
    def update_plugin(plugin_name: str, marketplace: str, success: bool) -> None:
        paths = get_cache_paths()
        ensure_cache_dir()
        cache_file = paths["plugins_cache"]
        key = f"{plugin_name}@{marketplace}"
        now = datetime.now().isoformat()
        entries = CacheManager._read_jsonl(cache_file)
        found = False
        for entry in entries:
            if entry.get("key") == key:
                entry["last_used"] = now
                entry["invocation_count"] = entry.get("invocation_count", 0) + 1
                if success:
                    entry["install_count"] = entry.get("install_count", 0) + 1
                    entry["use_count"] = entry.get("use_count", 0) + 1
                found = True
                log_debug(f"Updated plugin cache entry: {key}")
                break
        if not found:
            entries.append({
                "plugin": plugin_name, "marketplace": marketplace, "key": key,
                "first_seen": now, "last_used": now,
                "use_count": 1 if success else 0,
                "install_count": 1 if success else 0,
                "invocation_count": 1,
            })
            log_debug(f"Added new plugin cache entry: {key}")
        CacheManager._write_jsonl(cache_file, entries)

    @staticmethod
    def update_marketplace(marketplace: str) -> None:
        paths = get_cache_paths()
        ensure_cache_dir()
        cache_file = paths["marketplace_cache"]
        now = datetime.now().isoformat()
        entries = CacheManager._read_jsonl(cache_file)
        found = False
        for entry in entries:
            if entry.get("marketplace") == marketplace:
                entry["last_used"] = now
                found = True
                break
        if not found:
            entries.append({"marketplace": marketplace, "first_seen": now, "last_used": now})
        CacheManager._write_jsonl(cache_file, entries)

    @staticmethod
    def list_plugins() -> list[dict]:
        return CacheManager._read_jsonl(get_cache_paths()["plugins_cache"])

    @staticmethod
    def list_marketplaces() -> list[dict]:
        return CacheManager._read_jsonl(get_cache_paths()["marketplace_cache"])

    @staticmethod
    def remove_plugin(key: str) -> bool:
        paths = get_cache_paths()
        cache_file = paths["plugins_cache"]
        entries = CacheManager._read_jsonl(cache_file)
        before = len(entries)
        entries = [e for e in entries if e.get("key") != key]
        if len(entries) < before:
            CacheManager._write_jsonl(cache_file, entries)
            return True
        return False

    @staticmethod
    def clear() -> None:
        paths = get_cache_paths()
        for key in ("plugins_cache", "marketplace_cache"):
            path = paths[key]
            if path.exists():
                path.unlink()
                log_info(f"Removed {path}")


class LogManager:
    """Stateless manager for invocations.jsonl with auto-trim."""

    @staticmethod
    def append(entry: dict) -> None:
        paths = get_cache_paths()
        ensure_cache_dir()
        log_file = paths["invocations_log"]
        line = json.dumps(entry, separators=(",", ":")) + "\n"
        with open(log_file, "a") as f:
            f.write(line)
        log_debug(f"Logged invocation: action={entry.get('action')}")
        LogManager._auto_trim(log_file)

    @staticmethod
    def _auto_trim(log_file: Path) -> None:
        try:
            with open(log_file) as f:
                lines = f.readlines()
        except FileNotFoundError:
            return
        if len(lines) <= LOG_MIN_ENTRIES * 2:
            log_trace(f"Log has {len(lines)} lines, no trim needed (threshold: {LOG_MIN_ENTRIES * 2})")
            return
        log_info(f"Auto-trimming log from {len(lines)} to {LOG_MIN_ENTRIES} entries")
        keep = lines[-LOG_MIN_ENTRIES:]
        tmp_path = log_file.with_suffix(".tmp")
        with open(tmp_path, "w") as f:
            f.writelines(keep)
        os.replace(tmp_path, log_file)

    @staticmethod
    def show(last_n: int = 10) -> list[dict]:
        paths = get_cache_paths()
        log_file = paths["invocations_log"]
        if not log_file.exists():
            return []
        entries = []
        with open(log_file) as f:
            for line in f:
                line = line.strip()
                if line:
                    try:
                        entries.append(json.loads(line))
                    except json.JSONDecodeError:
                        pass
        return entries[-last_n:]

    @staticmethod
    def trim(keep_n: Optional[int] = None, days: Optional[int] = None) -> int:
        paths = get_cache_paths()
        log_file = paths["invocations_log"]
        if not log_file.exists():
            return 0
        with open(log_file) as f:
            lines = f.readlines()
        original_count = len(lines)
        if days is not None:
            cutoff = datetime.now().timestamp() - (days * 86400)
            kept = []
            for line in lines:
                line_s = line.strip()
                if not line_s:
                    continue
                try:
                    entry = json.loads(line_s)
                    ts = datetime.fromisoformat(entry["timestamp"]).timestamp()
                    if ts >= cutoff:
                        kept.append(line)
                except (json.JSONDecodeError, KeyError, ValueError):
                    kept.append(line)
            if keep_n is None and len(kept) < LOG_MIN_ENTRIES:
                kept = lines[-LOG_MIN_ENTRIES:] if len(lines) >= LOG_MIN_ENTRIES else lines
            lines = kept
        if keep_n is not None:
            lines = lines[-keep_n:] if len(lines) > keep_n else lines
        tmp_path = log_file.with_suffix(".tmp")
        with open(tmp_path, "w") as f:
            f.writelines(lines)
        os.replace(tmp_path, log_file)
        return original_count - len(lines)


def build_invocation_entry(
    plugin_key: str, plugin_name: str, marketplace: str, action: str,
    args: argparse.Namespace, project_path: Path, paths: dict,
    backup_paths: list, success: bool, error: Optional[str],
    interactive_answers: dict
) -> dict:
    settings_file = str(paths.get("settings", ""))
    backup_path = str(backup_paths[-1]) if backup_paths else ""
    def resolve(p: str) -> str:
        try:
            return str(Path(p).resolve()) if p else ""
        except (OSError, ValueError):
            return p
    return {
        "timestamp": datetime.now().isoformat(),
        "plugin_key": plugin_key,
        "plugin": plugin_name,
        "marketplace": marketplace,
        "action": action,
        "repo_git_root": str(project_path),
        "repo_git_root_resolved": resolve(str(project_path)),
        "settings_file": settings_file,
        "settings_file_resolved": resolve(settings_file),
        "backup_path": backup_path,
        "backup_path_resolved": resolve(backup_path),
        "scope": getattr(args, 'scope', 'project-local'),
        "argv": sys.argv,
        "dry_run": getattr(args, 'dry_run', False),
        "interactive_answers": interactive_answers,
        "success": success,
        "error": error,
        "version": VERSION,
    }


class ScopeDetector:
    """Detect which scopes have a plugin installed."""

    SCOPE_FILES = {
        "project-local": lambda repo: repo / ".claude" / "settings.local.json",
        "project-shared": lambda repo: repo / ".claude" / "settings.json",
        "user": lambda _: Path.home() / ".claude" / "settings.json",
    }

    SCOPE_SHORTCUTS = {
        "project-local": "local",
        "project-shared": "shared",
        "user": "global",
    }

    @staticmethod
    def detect_installed_scopes(plugin_key: str, repo_path: Path) -> list[dict]:
        results = []
        for scope, path_fn in ScopeDetector.SCOPE_FILES.items():
            settings_file = path_fn(repo_path)
            if not settings_file.exists():
                log_trace(f"Scope {scope}: file not found ({settings_file})")
                continue
            try:
                with open(settings_file) as f:
                    data = json.load(f)
                if data.get("enabledPlugins", {}).get(plugin_key):
                    results.append({
                        "scope": scope, "file": settings_file,
                        "shortcut": ScopeDetector.SCOPE_SHORTCUTS[scope],
                    })
                    log_debug(f"Scope {scope}: plugin enabled")
                else:
                    log_trace(f"Scope {scope}: plugin not in enabledPlugins")
            except (json.JSONDecodeError, IOError) as e:
                log_warn(f"Could not read {settings_file}: {e}")
        return results

    @staticmethod
    def detect_all_installed_plugins(repo_path: Path) -> dict[str, list[str]]:
        plugins: dict[str, list[str]] = {}
        for scope, path_fn in ScopeDetector.SCOPE_FILES.items():
            settings_file = path_fn(repo_path)
            if not settings_file.exists():
                continue
            try:
                with open(settings_file) as f:
                    data = json.load(f)
                for key, enabled in data.get("enabledPlugins", {}).items():
                    if enabled:
                        if key not in plugins:
                            plugins[key] = []
                        plugins[key].append(scope)
            except (json.JSONDecodeError, IOError):
                pass
        return plugins


def get_known_marketplaces() -> list[str]:
    """Get list of known marketplaces from Claude Code config."""
    path = Path.home() / ".claude" / "plugins" / "known_marketplaces.json"
    if not path.exists():
        return []
    try:
        with open(path) as f:
            data = json.load(f)
        return list(data.keys())
    except (json.JSONDecodeError, IOError):
        return []


def find_similar_names(target: str, candidates: list[str], threshold: float = 0.6) -> list[str]:
    """Find similar names using simple character-based similarity."""
    def similarity(a: str, b: str) -> float:
        a, b = a.lower(), b.lower()
        if a == b:
            return 1.0
        if a in b or b in a:
            return 0.8
        common = sum(1 for c in a if c in b)
        return common / max(len(a), len(b))

    similar = []
    for candidate in candidates:
        if similarity(target, candidate) >= threshold:
            similar.append(candidate)
    return similar


def print_banner(plugin_name: str, marketplace: str) -> None:
    plugin_key = f"{plugin_name}@{marketplace}"
    print(color(f"""
╔══════════════════════════════════════════════════════════════════════════════╗
║        CLAUDE CODE PLUGIN INSTALLATION FIX                                   ║
║                                                                              ║
║  Plugin: {plugin_key:<63} ║
║                                                                              ║
║  This script applies a workaround for the plugin installation bug.           ║
║  All files will be backed up before modification.                            ║
╚══════════════════════════════════════════════════════════════════════════════╝
""", Colors.CYAN))


def print_debug_info(error_context: str, locals_snapshot: dict[str, Any]) -> None:
    print(color("""
╔══════════════════════════════════════════════════════════════════════════════╗
║  DEBUG INFORMATION - Please include this when reporting issues               ║
╚══════════════════════════════════════════════════════════════════════════════╝
""", Colors.RED))

    debug_info = {
        "timestamp": datetime.now().isoformat(),
        "python_version": sys.version,
        "platform": sys.platform,
        "cwd": os.getcwd(),
        "error_context": error_context,
        "home": str(Path.home()),
        "relevant_state": {k: str(v) for k, v in locals_snapshot.items() if not k.startswith('_')}
    }

    print("```json")
    print(json.dumps(debug_info, indent=2))
    print("```")
    print(color("""
╔══════════════════════════════════════════════════════════════════════════════╗
║  WHERE TO REPORT                                                             ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  For the UPSTREAM Claude Code bug (plugin name collision):                   ║
║    Comment "me too" or describe your issue at:                               ║
║    https://github.com/anthropics/claude-code/issues/14202                    ║
║                                                                              ║
║  For issues with THIS WORKAROUND SCRIPT:                                     ║
║    https://github.com/shibuido/claude-plugin-install/issues                  ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝
""", Colors.YELLOW))


def ask_confirmation(prompt: str, non_interactive: bool) -> bool:
    if non_interactive:
        log_info(f"Non-interactive mode: auto-confirming '{prompt}'")
        return True
    try:
        response = input(f"\n{color('?', Colors.YELLOW)} {prompt} [y/N]: ").strip().lower()
    except EOFError:
        return False
    return response in ('y', 'yes')


def backup_file(filepath: Path) -> Optional[Path]:
    if not filepath.exists():
        log_debug(f"File does not exist, no backup needed: {filepath}")
        return None

    timestamp = datetime.now().strftime("%Y-%m-%d--%H-%M-%S")
    backup_path = filepath.with_suffix(f"{filepath.suffix}.bak.{timestamp}")

    log_debug(f"Creating backup: {filepath} -> {backup_path}")
    shutil.copy2(filepath, backup_path)
    log_success(f"Backed up: {backup_path}")
    return backup_path


def get_paths(scope: str, project_path: Path, plugin_name: str, marketplace: str) -> dict[str, Path]:
    home = Path.home()
    claude_home = home / ".claude"

    paths = {
        "installed_plugins": claude_home / "plugins" / "installed_plugins.json",
        "known_marketplaces": claude_home / "plugins" / "known_marketplaces.json",
        "plugin_cache": claude_home / "plugins" / "cache" / marketplace / plugin_name,
    }

    if scope == "user":
        paths["settings"] = claude_home / "settings.json"
    elif scope == "project-shared":
        paths["settings"] = project_path / ".claude" / "settings.json"
    else:  # project-local (default)
        paths["settings"] = project_path / ".claude" / "settings.local.json"

    paths["project_claude_dir"] = project_path / ".claude"

    return paths


def verify_assumptions(paths: dict[str, Path], marketplace: str, plugin_name: str) -> tuple[bool, list[str]]:
    errors = []

    log_step("Verifying assumptions...")

    if not paths["installed_plugins"].exists():
        errors.append(f"installed_plugins.json not found at: {paths['installed_plugins']}")
    else:
        log_success(f"Found installed_plugins.json")
        log_debug(f"  Path: {paths['installed_plugins']}")

    if not paths["known_marketplaces"].exists():
        errors.append(f"known_marketplaces.json not found at: {paths['known_marketplaces']}")
    else:
        log_success(f"Found known_marketplaces.json")

        try:
            with open(paths["known_marketplaces"]) as f:
                marketplaces = json.load(f)
            if marketplace not in marketplaces:
                similar = find_similar_names(marketplace, list(marketplaces.keys()))
                err_msg = f"'{marketplace}' not found in known_marketplaces.json."
                if similar:
                    err_msg += f" Did you mean: {', '.join(similar)}?"
                else:
                    err_msg += f" Run: /plugin marketplace add OWNER/{marketplace}"
                errors.append(err_msg)
            else:
                log_success(f"'{marketplace}' is registered")
                log_trace(f"  Config: {json.dumps(marketplaces[marketplace], indent=2)}")
        except json.JSONDecodeError as e:
            errors.append(f"Invalid JSON in known_marketplaces.json: {e}")

    if not paths["plugin_cache"].exists():
        errors.append(f"Plugin cache not found at: {paths['plugin_cache']}. "
                     f"The marketplace may not have been synced. Try: /plugin marketplace add OWNER/{marketplace}")
    else:
        log_success(f"Found plugin cache for '{plugin_name}'")
        versions = list(paths["plugin_cache"].iterdir())
        if versions:
            log_debug(f"  Available versions: {[v.name for v in versions]}")

    return (len(errors) == 0, errors)


def get_plugin_version(paths: dict[str, Path]) -> Optional[str]:
    cache_path = paths["plugin_cache"]
    if not cache_path.exists():
        return None

    versions = sorted(cache_path.iterdir(), key=lambda p: p.stat().st_mtime, reverse=True)
    if versions:
        return versions[0].name
    return None


def check_already_installed(paths: dict[str, Path], project_path: Path, plugin_key: str) -> bool:
    if not paths["installed_plugins"].exists():
        return False

    try:
        with open(paths["installed_plugins"]) as f:
            data = json.load(f)

        if plugin_key not in data.get("plugins", {}):
            return False

        installations = data["plugins"][plugin_key]
        project_str = str(project_path)

        for inst in installations:
            if inst.get("scope") == "user":
                log_warn(f"{plugin_key} is installed at user scope (globally)")
                return True
            if inst.get("projectPath") == project_str:
                log_warn(f"{plugin_key} is already installed for this project")
                return True

        return False
    except (json.JSONDecodeError, KeyError) as e:
        log_debug(f"Error checking installation: {e}")
        return False


def update_installed_plugins(paths: dict[str, Path], project_path: Path, scope: str,
                            plugin_key: str) -> bool:
    filepath = paths["installed_plugins"]

    try:
        with open(filepath) as f:
            data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError) as e:
        log_error(f"Failed to read {filepath}: {e}")
        return False

    version = get_plugin_version(paths) or "unknown"
    now = datetime.now().isoformat()

    new_entry: dict[str, Any] = {
        "installPath": str(paths["plugin_cache"] / version),
        "version": version,
        "installedAt": now,
        "lastUpdated": now,
    }

    if scope == "user":
        new_entry["scope"] = "user"
    else:
        new_entry["scope"] = "local"
        new_entry["projectPath"] = str(project_path)

    if "plugins" not in data:
        data["plugins"] = {}

    if plugin_key not in data["plugins"]:
        data["plugins"][plugin_key] = []

    data["plugins"][plugin_key].append(new_entry)

    log_trace(f"New entry: {json.dumps(new_entry, indent=2)}")

    try:
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)
        log_success(f"Updated {filepath}")
        return True
    except IOError as e:
        log_error(f"Failed to write {filepath}: {e}")
        return False


def update_settings(paths: dict[str, Path], plugin_key: str) -> bool:
    filepath = paths["settings"]

    if filepath.exists():
        try:
            with open(filepath) as f:
                data = json.load(f)
        except json.JSONDecodeError as e:
            log_error(f"Invalid JSON in {filepath}: {e}")
            return False
    else:
        data = {}
        filepath.parent.mkdir(parents=True, exist_ok=True)

    if "enabledPlugins" not in data:
        data["enabledPlugins"] = {}

    data["enabledPlugins"][plugin_key] = True

    log_trace(f"Settings will be: {json.dumps(data, indent=2)}")

    try:
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)
            f.write('\n')
        log_success(f"Updated {filepath}")
        return True
    except IOError as e:
        log_error(f"Failed to write {filepath}: {e}")
        return False


def validate_plugin_arg(plugin_arg: str) -> tuple[Optional[str], Optional[str], Optional[str]]:
    """
    Validate and parse plugin@marketplace argument.
    Returns (plugin_name, marketplace, error_message).
    If error_message is set, the other values are None.
    """
    if "@" not in plugin_arg:
        known = get_known_marketplaces()
        error_lines = [
            f"Invalid plugin format. Expected: plugin@marketplace",
            f"",
            f"You provided: {plugin_arg}",
            f"",
        ]
        if known:
            error_lines.append("Available marketplaces on your system:")
            for m in known:
                error_lines.append(f"  - {m}")
            error_lines.append("")
        error_lines.append(f"Example: ./claude-plugin-install -p {plugin_arg}@MARKETPLACE_NAME")
        return None, None, "\n".join(error_lines)

    parts = plugin_arg.split("@", 1)
    plugin_name = parts[0].strip()
    marketplace = parts[1].strip()

    if not plugin_name:
        return None, None, "Plugin name cannot be empty. Expected: plugin@marketplace"

    if not marketplace:
        return None, None, "Marketplace cannot be empty. Expected: plugin@marketplace"

    # Check if marketplace exists
    known = get_known_marketplaces()
    if known and marketplace not in known:
        similar = find_similar_names(marketplace, known)
        error_lines = [
            f"Marketplace '{marketplace}' not found in your Claude Code configuration.",
            f"",
        ]
        if similar:
            error_lines.append(f"Did you mean: {', '.join(similar)}?")
            error_lines.append("")
        error_lines.append("Available marketplaces:")
        for m in known:
            error_lines.append(f"  - {m}")
        error_lines.append("")
        error_lines.append("To add a new marketplace in Claude Code:")
        error_lines.append(f"  /plugin marketplace add owner/{marketplace}")
        error_lines.append("")
        error_lines.append("If adding the marketplace also fails and needs a workaround,")
        error_lines.append("please file a feature request: https://github.com/shibuido/claude-plugin-install/issues")
        return None, None, "\n".join(error_lines)

    return plugin_name, marketplace, None


class MenuHandler:
    """Interactive menu for plugin management."""

    @staticmethod
    def display_menu(repo_path: Path) -> Optional[dict]:
        """Display interactive menu and return selection."""
        print(f"\n{color('Plugin Manager', Colors.CYAN)} | Repo: {color(str(repo_path), Colors.BOLD)}\n")
        installed = ScopeDetector.detect_all_installed_plugins(repo_path)
        cached = CacheManager.list_plugins()
        items = []
        idx = 1

        if installed:
            print(color("-- Installed plugins --------------------------", Colors.GREEN))
            for key, scopes in sorted(installed.items()):
                scope_str = ", ".join(
                    f"{ScopeDetector.SCOPE_SHORTCUTS.get(s, s)}" for s in scopes
                )
                print(f"  [{idx}] {color(key, Colors.BOLD)}  ({scope_str})")
                items.append({"idx": idx, "key": key, "installed": True, "scopes": scopes})
                idx += 1
            print()

        remembered = [e for e in cached if e["key"] not in installed]
        if remembered:
            print(color("-- Remembered plugins (used before) -----------", Colors.BLUE))
            for entry in remembered:
                count = entry.get("install_count", 0)
                try:
                    from_dt = datetime.fromisoformat(entry.get("last_used", ""))
                    delta = datetime.now() - from_dt
                    if delta.days == 0:
                        ago = "today"
                    elif delta.days == 1:
                        ago = "1d ago"
                    elif delta.days < 7:
                        ago = f"{delta.days}d ago"
                    elif delta.days < 30:
                        ago = f"{delta.days // 7}w ago"
                    else:
                        ago = f"{delta.days // 30}mo ago"
                except (ValueError, TypeError):
                    ago = "?"
                print(f"  [{idx}] {entry['key']}  (last: {ago}, {count} installs)")
                items.append({"idx": idx, "key": entry["key"], "installed": False})
                idx += 1
            print()

        if not items:
            print("  No installed or remembered plugins.")
            print(f"  Type a plugin@marketplace to install, or 'q' to quit.\n")

        try:
            choice = input(f"Select [1-{max(1, idx-1)}] or type plugin@marketplace (q=quit): ").strip()
        except (EOFError, KeyboardInterrupt):
            print()
            return None

        if not choice or choice.lower() == "q":
            return None

        try:
            num = int(choice)
            for item in items:
                if item["idx"] == num:
                    return item
            print(f"Invalid selection: {num}")
            return None
        except ValueError:
            pass

        if "@" in choice:
            return {"key": choice, "installed": False, "typed": True}

        print(f"Invalid input. Use a number or plugin@marketplace format.")
        return None

    @staticmethod
    def handle_installed_selection(plugin_key: str, scopes: list[str], repo_path: Path) -> Optional[dict]:
        """Handle selection of an already-installed plugin."""
        print(f"\n{color('Selected:', Colors.BOLD)} {plugin_key}")
        print("Currently enabled in:")
        for i, scope in enumerate(scopes, 1):
            shortcut = ScopeDetector.SCOPE_SHORTCUTS.get(scope, scope)
            path_fn = ScopeDetector.SCOPE_FILES[scope]
            print(f"  [{i}] {shortcut}  ({path_fn(repo_path)})")
        print(f"\n  [u] Uninstall from selected scope(s)")
        print(f"  [a] Uninstall from all")
        print(f"  [b] Back")
        try:
            action = input(f"\nAction: ").strip().lower()
        except (EOFError, KeyboardInterrupt):
            print()
            return None
        if action == "b" or not action:
            return None
        elif action == "a":
            return {"action": "uninstall", "plugin_key": plugin_key, "scopes": scopes}
        elif action == "u":
            print("Enter scope numbers (comma-separated) to uninstall from:")
            try:
                picks = input("> ").strip()
            except (EOFError, KeyboardInterrupt):
                return None
            selected_scopes = []
            for p in picks.split(","):
                p = p.strip()
                try:
                    i = int(p) - 1
                    if 0 <= i < len(scopes):
                        selected_scopes.append(scopes[i])
                except ValueError:
                    pass
            if selected_scopes:
                return {"action": "uninstall", "plugin_key": plugin_key, "scopes": selected_scopes}
        return None


def cmd_interactive_menu(args) -> int:
    """Interactive menu when no -p plugin is provided."""
    project_path = args.project_path.resolve()
    selection = MenuHandler.display_menu(project_path)
    if selection is None:
        return 0
    plugin_key = selection["key"]
    if selection.get("installed"):
        result = MenuHandler.handle_installed_selection(
            plugin_key, selection["scopes"], project_path
        )
        if result and result.get("action") == "uninstall":
            args.plugin = plugin_key
            args.all_scopes = len(result["scopes"]) == len(ScopeDetector.SCOPE_FILES)
            args.subcommand = "uninstall"
            if not args.all_scopes and len(result["scopes"]) == 1:
                args.scope_shortcut = result["scopes"][0]
                args.scope = result["scopes"][0]
            return cmd_uninstall(args)
        return 0
    else:
        plugin_name, marketplace, error = validate_plugin_arg(plugin_key)
        if error:
            log_error(error)
            return 1
        args.plugin = plugin_key
        return cmd_install(args)


def cmd_install(args) -> int:
    """Install a plugin (extracted from old main)."""
    plugin_name, marketplace, error = validate_plugin_arg(args.plugin)
    if error:
        log_error(error)
        return 1

    plugin_key = f"{plugin_name}@{marketplace}"

    # Print banner
    print_banner(plugin_name, marketplace)

    project_path = args.project_path.resolve()
    scope = getattr(args, 'scope', 'project-local')
    paths = get_paths(scope, project_path, plugin_name, marketplace)

    log_info(f"Plugin: {plugin_key}")
    log_info(f"Project path: {project_path}")
    log_info(f"Scope: {scope}")
    log_debug(f"Paths: {', '.join(f'{k}={v}' for k, v in paths.items())}")
    log_trace(f"Verbosity level: {VERBOSITY}")

    dry_run = getattr(args, 'dry_run', False)
    non_interactive = getattr(args, 'non_interactive', False)

    if dry_run:
        log_warn("DRY RUN MODE - No changes will be made")

    # === IMPORTANT WARNING ===
    log_step("Pre-flight checks")
    print(color("""
┌──────────────────────────────────────────────────────────────────────────────┐
│  IMPORTANT: Please close Claude Code in this directory before proceeding     │
│                                                                              │
│  This script modifies .claude/settings files. If Claude Code is running,     │
│  there may be a race condition where your changes get overwritten.           │
│                                                                              │
│  To close Claude Code:                                                       │
│    - In the Claude Code TUI, type /exit or press Ctrl+C                      │
│    - Or close the terminal/tmux pane running Claude Code                     │
│                                                                              │
│  Don't worry - all files will be backed up before any modifications!         │
└──────────────────────────────────────────────────────────────────────────────┘
""", Colors.YELLOW))

    if not ask_confirmation("Have you closed Claude Code in this directory?", non_interactive):
        print("Please close Claude Code and run this script again.")
        return 0

    # === VERIFY ASSUMPTIONS ===
    success, errors = verify_assumptions(paths, marketplace, plugin_name)

    if not success:
        log_error("Assumption verification failed!")
        for err in errors:
            log_error(f"  - {err}")
        print_debug_info("Assumption verification failed", {
            "paths": {k: str(v) for k, v in paths.items()},
            "errors": errors,
            "project_path": str(project_path),
            "scope": scope,
            "plugin_key": plugin_key,
        })
        return 1

    # === CHECK IF ALREADY INSTALLED ===
    log_step("Checking current installation status")

    if check_already_installed(paths, project_path, plugin_key):
        if not ask_confirmation("Plugin appears to be already installed. Continue anyway?", non_interactive):
            print("Exiting without changes.")
            return 0
    else:
        log_success("Plugin not yet installed for this project/scope")

    # === SHOW WHAT WILL BE MODIFIED ===
    log_step("Files to be modified")

    files_to_modify = [
        paths["installed_plugins"],
        paths["settings"],
    ]

    for f in files_to_modify:
        status = "exists" if f.exists() else "will be created"
        print(f"  - {f} ({status})")

    if dry_run:
        print("DRY RUN: Would modify the above files")
        CacheManager.update_plugin(plugin_name, marketplace, success=False)
        CacheManager.update_marketplace(marketplace)
        log_entry = build_invocation_entry(
            plugin_key=plugin_key, plugin_name=plugin_name, marketplace=marketplace,
            action="install", args=args, project_path=project_path, paths=paths,
            backup_paths=[], success=True, error=None,
            interactive_answers={"dry_run": True}
        )
        LogManager.append(log_entry)
        return 0

    if not ask_confirmation("Proceed with modifications?", non_interactive):
        print("Exiting without changes.")
        return 0

    # === CREATE BACKUPS ===
    log_step("Creating backups")

    backups = []
    for f in files_to_modify:
        backup = backup_file(f)
        if backup:
            backups.append(backup)

    if not backups:
        log_info("No existing files to back up")

    # === APPLY MODIFICATIONS ===
    log_step("Applying modifications")

    log_info("Updating installed_plugins.json...")
    if not update_installed_plugins(paths, project_path, scope, plugin_key):
        log_error("Failed to update installed_plugins.json")
        print_debug_info("Failed to update installed_plugins.json", {
            "paths": {k: str(v) for k, v in paths.items()},
            "project_path": str(project_path),
            "scope": scope,
            "plugin_key": plugin_key,
        })
        return 1

    log_info(f"Updating {paths['settings'].name}...")
    if not update_settings(paths, plugin_key):
        log_error(f"Failed to update {paths['settings']}")
        print_debug_info("Failed to update settings", {
            "paths": {k: str(v) for k, v in paths.items()},
            "project_path": str(project_path),
            "scope": scope,
            "plugin_key": plugin_key,
        })
        return 1

    # === SUCCESS ===
    print(color("""
╔══════════════════════════════════════════════════════════════════════════════╗
║  SUCCESS! Plugin installation workaround applied.                            ║
╚══════════════════════════════════════════════════════════════════════════════╝
""", Colors.GREEN))

    print("Next steps:")
    print(f"  1. Start Claude Code in this directory: {color('claude', Colors.CYAN)}")
    print(f"  2. Run {color('/plugin', Colors.CYAN)} and check the Installed tab")
    print(f"  3. You should see: {color(f'{plugin_name} Plugin · {marketplace} · enabled', Colors.GREEN)}")

    if backups:
        print(f"\nBackups created:")
        for b in backups:
            print(f"  - {b}")

    # === UPDATE CACHE & LOG ===
    CacheManager.update_plugin(plugin_name, marketplace, success=True)
    CacheManager.update_marketplace(marketplace)
    log_entry = build_invocation_entry(
        plugin_key=plugin_key, plugin_name=plugin_name, marketplace=marketplace,
        action="install", args=args, project_path=project_path, paths=paths,
        backup_paths=backups, success=True, error=None,
        interactive_answers={}
    )
    LogManager.append(log_entry)

    return 0


def cmd_uninstall(args) -> int:
    """Uninstall a plugin from one or more scopes."""
    plugin_arg = args.plugin
    plugin_name, marketplace, error = validate_plugin_arg(plugin_arg)
    if error:
        log_error(error)
        return 1
    plugin_key = f"{plugin_name}@{marketplace}"
    project_path = args.project_path.resolve()

    scopes = ScopeDetector.detect_installed_scopes(plugin_key, project_path)
    if not scopes:
        log_warn(f"{plugin_key} is not installed in any scope for {project_path}")
        return 0

    non_interactive = getattr(args, 'non_interactive', False)
    scope_shortcut = getattr(args, 'scope_shortcut', None)

    if getattr(args, "all_scopes", False):
        target_scopes = scopes
    elif scope_shortcut:
        target_scopes = [s for s in scopes if s["scope"] == scope_shortcut]
        if not target_scopes:
            log_warn(f"{plugin_key} is not installed in scope {scope_shortcut}")
            return 0
    elif non_interactive:
        log_error("Non-interactive uninstall requires -l, -g, -r, or --all")
        return 1
    else:
        # Interactive scope selection
        print(f"\n{color('Uninstall:', Colors.BOLD)} {plugin_key}")
        print("Found in scopes:")
        for i, s in enumerate(scopes, 1):
            print(f"  [{i}] {s['shortcut']}  ({s['file']})")
        print(f"  [a] All scopes")
        try:
            choice = input(f"\nUninstall from (numbers/a): ").strip().lower()
        except (EOFError, KeyboardInterrupt):
            print()
            return 0
        if choice == "a":
            target_scopes = scopes
        else:
            target_scopes = []
            for c in choice.split(","):
                c = c.strip()
                try:
                    i = int(c) - 1
                    if 0 <= i < len(scopes):
                        target_scopes.append(scopes[i])
                except ValueError:
                    pass
        if not target_scopes:
            print("No scopes selected, exiting.")
            return 0

    backup_paths = []
    for scope_info in target_scopes:
        settings_file = scope_info["file"]
        log_info(f"Removing {plugin_key} from {scope_info['shortcut']} ({settings_file})")
        backup = backup_file(settings_file)
        if backup:
            backup_paths.append(backup)
        try:
            with open(settings_file) as f:
                data = json.load(f)
            if plugin_key in data.get("enabledPlugins", {}):
                del data["enabledPlugins"][plugin_key]
                with open(settings_file, "w") as f:
                    json.dump(data, f, indent=2)
                    f.write("\n")
                log_success(f"Removed from {scope_info['shortcut']}")
            else:
                log_warn(f"Not found in {scope_info['shortcut']} (already removed?)")
        except (json.JSONDecodeError, IOError) as e:
            log_error(f"Failed to update {settings_file}: {e}")
            return 1

    # Clean installed_plugins.json if no scopes remain
    remaining = ScopeDetector.detect_installed_scopes(plugin_key, project_path)
    if not remaining:
        installed_plugins = Path.home() / ".claude" / "plugins" / "installed_plugins.json"
        if installed_plugins.exists():
            try:
                backup = backup_file(installed_plugins)
                if backup:
                    backup_paths.append(backup)
                with open(installed_plugins) as f:
                    data = json.load(f)
                if plugin_key in data.get("plugins", {}):
                    entries = data["plugins"][plugin_key]
                    entries = [e for e in entries if e.get("projectPath") != str(project_path)]
                    if entries:
                        data["plugins"][plugin_key] = entries
                    else:
                        del data["plugins"][plugin_key]
                    with open(installed_plugins, "w") as f:
                        json.dump(data, f, indent=2)
                    log_success("Cleaned up installed_plugins.json")
            except (json.JSONDecodeError, IOError) as e:
                log_warn(f"Could not clean installed_plugins.json: {e}")

    log_entry = build_invocation_entry(
        plugin_key=plugin_key, plugin_name=plugin_name, marketplace=marketplace,
        action="uninstall", args=args, project_path=project_path,
        paths={"settings": str(target_scopes[0]["file"]) if target_scopes else ""},
        backup_paths=backup_paths, success=True, error=None,
        interactive_answers={},
    )
    LogManager.append(log_entry)
    CacheManager.update_plugin(plugin_name, marketplace, success=False)

    print(color(f"\nUninstalled {plugin_key}", Colors.GREEN))
    return 0


def cmd_cache(args) -> int:
    """Manage plugin memory cache."""
    action = getattr(args, "cache_action", None)
    if action == "list":
        entries = CacheManager.list_plugins()
        if not entries:
            print("No remembered plugins.")
            return 0
        for e in entries:
            print(f"  {e['key']}  (installs: {e.get('install_count', 0)}, last: {e.get('last_used', '?')[:10]})")
        return 0
    elif action == "list-marketplaces":
        entries = CacheManager.list_marketplaces()
        if not entries:
            print("No remembered marketplaces.")
            return 0
        for e in entries:
            print(f"  {e['marketplace']}  (last: {e.get('last_used', '?')[:10]})")
        return 0
    elif action == "remove":
        if CacheManager.remove_plugin(args.plugin):
            log_success(f"Removed {args.plugin} from plugin memory")
        else:
            log_warn(f"{args.plugin} not found in plugin memory")
        return 0
    elif action == "clear":
        CacheManager.clear()
        log_success("Plugin memory cleared")
        return 0
    else:
        print("Usage: claude-plugin-install cache {list|list-marketplaces|remove|clear}")
        return 1


def cmd_log(args) -> int:
    """Manage invocation log."""
    action = getattr(args, "log_action", None)
    if action == "show":
        entries = LogManager.show(args.last)
        if not entries:
            print("No invocation history.")
            return 0
        for e in entries:
            ts = e.get("timestamp", "?")[:19]
            key = e.get("plugin_key", "?")
            act = e.get("action", "?")
            ok = "ok" if e.get("success") else "err"
            print(f"  {ts}  {ok} {act:10s} {key}")
        return 0
    elif action == "trim":
        removed = LogManager.trim(keep_n=getattr(args, "keep", None), days=getattr(args, "days", None))
        log_success(f"Trimmed {removed} entries from invocation log")
        return 0
    else:
        print("Usage: claude-plugin-install log {show|trim}")
        return 1


def build_parser() -> argparse.ArgumentParser:
    """Build the argument parser with subcommands."""
    parser = argparse.ArgumentParser(
        description="claude-plugin-install -- Install, manage, and remember Claude Code plugins",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EXAMPLES:
  claude-plugin-install                                         # interactive menu
  claude-plugin-install -p superpowers@superpowers-marketplace  # install
  claude-plugin-install -p superpowers@superpowers-marketplace -y  # non-interactive
  claude-plugin-install uninstall superpowers@superpowers-marketplace
  claude-plugin-install cache list
  claude-plugin-install log show --last 20

SCOPE OPTIONS:
  project-local   Current user in this project (default). Uses: .claude/settings.local.json
  project-shared  All users of this project. Uses: .claude/settings.json (committed)
  user            All projects for current user. Uses: ~/.claude/settings.json

RELATED ISSUES:
  https://github.com/anthropics/claude-code/issues/20593
  https://github.com/anthropics/claude-code/issues/14202
"""
    )

    # Global flags
    parser.add_argument("-v", "--verbose", action="count", default=0,
                        help="Increase verbosity (-v=INFO, -vv=DEBUG, -vvv=TRACE)")
    parser.add_argument("-d", "--project-path", type=Path, default=Path.cwd(),
                        help="Project path (default: current directory)")

    # Install flags (for default/no-subcommand mode)
    parser.add_argument("-p", "--plugin", metavar="PLUGIN@MARKETPLACE",
                        help="Plugin to install (e.g., superpowers@superpowers-marketplace)")
    parser.add_argument("-y", "--yes", "--non-interactive", dest="non_interactive",
                        action="store_true", help="Non-interactive mode")
    parser.add_argument("-n", "--dry-run", action="store_true", help="Preview changes only")
    parser.add_argument("-s", "--scope", choices=["project-local", "project-shared", "user"],
                        default="project-local", help="Installation scope (default: project-local)")
    parser.add_argument("-l", dest="scope_shortcut", action="store_const",
                        const="project-local", help="Shortcut: project-local scope")
    parser.add_argument("-g", dest="scope_shortcut", action="store_const",
                        const="user", help="Shortcut: user/global scope")
    parser.add_argument("-r", dest="scope_shortcut", action="store_const",
                        const="project-shared", help="Shortcut: project-shared/repo scope")

    subparsers = parser.add_subparsers(dest="subcommand")

    # uninstall subcommand
    unsub = subparsers.add_parser("uninstall", help="Uninstall a plugin")
    unsub.add_argument("plugin", metavar="PLUGIN@MARKETPLACE", help="Plugin to uninstall")
    unsub.add_argument("-y", "--yes", dest="non_interactive", action="store_true")
    unsub.add_argument("-d", "--project-path", type=Path, default=Path.cwd())
    unsub.add_argument("-v", "--verbose", action="count", default=0)
    unsub.add_argument("-l", dest="scope_shortcut", action="store_const", const="project-local")
    unsub.add_argument("-g", dest="scope_shortcut", action="store_const", const="user")
    unsub.add_argument("-r", dest="scope_shortcut", action="store_const", const="project-shared")
    unsub.add_argument("--all", dest="all_scopes", action="store_true", help="Uninstall from all scopes")

    # cache subcommand
    cachesub = subparsers.add_parser("cache", help="Manage plugin memory cache")
    cache_sub = cachesub.add_subparsers(dest="cache_action")
    cache_sub.add_parser("list", help="List remembered plugins")
    cache_sub.add_parser("list-marketplaces", help="List remembered marketplaces")
    cache_rm = cache_sub.add_parser("remove", help="Forget a plugin")
    cache_rm.add_argument("plugin", metavar="PLUGIN@MARKETPLACE")
    cache_sub.add_parser("clear", help="Clear all plugin memory")

    # log subcommand
    logsub = subparsers.add_parser("log", help="Manage invocation log")
    log_sub = logsub.add_subparsers(dest="log_action")
    log_show = log_sub.add_parser("show", help="Show recent invocations")
    log_show.add_argument("--last", type=int, default=10, help="Number of entries")
    log_trim = log_sub.add_parser("trim", help="Trim log entries")
    log_trim.add_argument("--keep", type=int, help="Keep last N entries")
    log_trim.add_argument("--days", type=int, help="Keep entries from last N days")

    return parser


def main() -> int:
    parser = build_parser()
    args = parser.parse_args()

    global VERBOSITY
    VERBOSITY = args.verbose

    # Resolve scope shortcut
    if getattr(args, "scope_shortcut", None):
        args.scope = args.scope_shortcut

    ensure_cache_dir()

    # Route to subcommand handlers
    if args.subcommand == "uninstall":
        return cmd_uninstall(args)
    elif args.subcommand == "cache":
        return cmd_cache(args)
    elif args.subcommand == "log":
        return cmd_log(args)
    elif args.plugin:
        return cmd_install(args)
    else:
        return cmd_interactive_menu(args)


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nInterrupted by user")
        sys.exit(130)
    except Exception as e:
        log_error(f"Unexpected error: {e}")
        import traceback
        print_debug_info(f"Unexpected exception: {e}", {
            "traceback": traceback.format_exc(),
        })
        sys.exit(1)
